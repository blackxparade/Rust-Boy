\chapter{Az emulátor fejlesztési folyamata}

Ahogy már az elõzõ fejezetekben is említésre került, az emulátor fejlesztõi szubkultúrában többé-kevésbé kialakult egyfajta irányelv, amit érdemes követni az emulátor fejlesztésénél. Természetesen olyan leírást nem lehet készíteni ami bármilyen konzol emulátorának fej\-lesz\-té\-sé\-re használható -- a hardverek különbözõsége és a speciális megoldások nem teszik ezt lehetõvé. Azt viszont meg lehet tenni, hogy egy általános tervezési mintát meg\-ha\-tá\-ro\-zunk, és a tervezésnél - implementálásnál ezt követjük. \\
Az elsõ teendõ mindenképpen a lehetõ legtöbb tudásanyag összeszedése ilyen-olyan for\-rá\-sok\-ból: internetrõl, régi szaklapokból, esetleg magát a hardvert tanulmányozva. Nagy segítséget jelenthet például ha már valaki belekezdett ugyanazon hardver emulátorának fejlesztésébe, hiszen fontos információkkal szolgálhat. Egyes hardver emulátorok köré közösségek is összegyûlnek: így van ez a Game Boy esetén is. Ez a közösség egy honlapon gyûjtötte egybe az elérhetõ összes -- eddig fellelt -- információt a konzolról. A legfontosabb dokumentum azonban minden emulátor fejlesztése kapcsán a processzor dokumentációja, hiszen -- ahogy majd látni a késõbbiekben erre ki is térek -- ezt fogjuk elõször implementálni. Mielõtt az implementációs szakaszba lépnénk, célszerû átgondolni az emulátor leendõ struktúráját, mûködését, illetve az alkalmazott eszközöket. Továbbá az elvárt mûködést, \textit{input}, \textit{output} adatokat is át kell gondolni a tényleges fejlesztési munkálatok elõtt.

\section{A fõ ciklus}

%\begin{minted}{rust}
%pub struct Timer {
%    timer_counter : u32,
%    divider_register : u16,
%    pub TMC : u16,
%    TMA : u16,
%    TIMA : u16,
%    interrupt : Interrupt,
%}
%\end{minted}

A fõ ciklus a Game Boy utasítás-végrehajtását emulálja, aminek egy leegyszerûsített modellje bármilyen Neumann-elvû számítógép processzorára illeszkedni fog. Ezt a fõ ciklust elterjedtebb nevén \textbf{betöltõ-dekódoló-végrehajtó} ciklusnak is nevezik. Lépései a következõk:

\begin{enumerate}
  \item A soron következõ utasítás betöltése a memóriából az utasításregiszterbe.
  \item Az utasításszámláló (másnéven \textit{Program Counter}, vagy PC) beállítása a következõ utasítás címére.
  \item A beolvasott utasítás típusának meghatározása.
  \item Ha az utasítás memóriabeli szót használ, a szó helyének meghatározása.
  \item Ha szükséges, a szó beolvasása a CPU egy regiszterébe.
  \item Az utasítás végrehajtása.
  \item Vissza az 1. pontra.
\end{enumerate}

\noindent A fenti szerkezet valamilyen módon minden emulátorban megtalálható, ez a felépítés alapja. A ciklus addig ismétlõdik, amíg egy \texttt{HALT}, vagy egyéb kilépést/megállást szolgáló utasítás nem érkezik végrehajtásra. Természetesen a megszakításkezelõ valamelyest beleszól a ciklus mûködésébe, de errõl majd egy késõbbi fejezetben lesz szó. \\
A Game Boy emulátorban a fenti szerkezet egy egyszerûbb változata mûködik, ami vázlatszerûen így néz ki:

\begin{minted}{rust}
loop {  // endless loop
  let next_byte: Byte = fetch_byte();
  let instruction: Instruction = decode_instruction(next_byte);
  execute(instruction);
}
\end{minted}

\noindent A fenti függvényeket, és azok mûködését a késõbbiekben fogom részletezni.

\section{Alkalmazott eszközök}

A fejlesztéshez alkalmazott eszközök meghatározása fontos tényezõ, hiszen nagyban megkönnyíthetük vagy megnehezíthetjük a saját munkánkat. Elõször is célszerû egy prog\-ra\-mo\-zá\-si nyelvet választani, lehetõség szerint olyat, amihez léteznek olyan \textit{library}-k, amelyekkel megvalósítható a program. Emellett az is lényeges, hogy a programozási nyelv gyors binárist generáljon -- természetesen megvalósíthatjuk az emulátort \textit{Javascript} nyelven is, csak észrevehetõen lassabb lesz, mint mondjuk a \textit{C++}-os variánsa. \\
A programozási nyelv mellett a \textit{debug}-olást nagyban megkönnyíti egy \textit{disassembler}, vagy optimális esetben egy másik emulátorhoz készített \textit{debugger}. A ROM fájlokhoz szükséges lehet még egy \textit{hex editor}\footnote{A \textit{hex editor} egy olyan szoftver, amely segítségével megtekinteni és módosítani lehet egy bináris adatfájlt. A "\textit{hex}" elõtag a hexadecimális rövidítésbõl ered: a bináris fájl bájtjait 16-os számrendszerben mutatja a program.}, hogy pontosan lássuk azt, hogy milyen bájtokkal dolgozunk. Ahhoz hogy lássuk, hogy a memóriában milyen adatok szerepelnek, célszerû egy memória térkép eszközt készíteni a fejlesztés során. 

\subsection{A Rust programozási nyelv}
Az emulátor fejlesztéséhez a Rust programozási nyelvet választottam, több okból. Egyrészt ez elõtt egy kisebb emulátor projekten dolgoztam a nyelvvel, és már akkor megtetszett az egyszerûsége, a környezete, a nyelv köré alakult közösség. Másrészt a nyelvet az ehhez hasonló performancia-orientált feladatokra tervezték.\\
A \textbf{Rust} a fejlesztõk weboldala szerint egy 2006 óta fejlesztett, rendszerfejlesztésre készített nyelv, amely villám gyorsan dolgozik, megelõzi a szegmentációs hibákat, és garantáltan gátolja a versenyhelyzetek kialakulását. Erõsen típusos nyelv, szintaktikailag a C++-hoz hasonlít, viszont hozzá képest biztonságosabb memóriakezelést biztosít a sebesség meg\-tar\-tá\-sá\-val. A Rust világában tehát nincsen null pointer, lógó pointer, és versenyhelyzet sem. A fejlesztését és tervezését a Mozilla kutatói részlege kezdte el, majd idõvel kö\-zös\-sé\-gi projektté alakult. Jelenleg \texttt{1.24.1}-es jelzésû az aktuális verzió. \\
Fontos még megemlíteni, hogy a \textit{Stack Overflow} weboldalon megrendezett éves fejlesztõi kérdõív kitöltések alapján 2016-ban, 2017-ben és 2018-ban is a Rust nyerte a "leginkább kedvelt programozási nyelv" kategóriát. Egyéb érdekesség, hogy jól megfigyelhetõ, hogy az emulátor fejlesztõ közösség túlnyomó többsége vagy C++-ban, vagy Rust-ban fejleszt -- ez a nyelv kényelmességének, eleganciájának és sokoldalúságának is köszönhetõ. \\
Maga a nyelv szépsége azonban még nem minden -- a nyelv mellett a \textbf{Cargo} eszköz egy fontos szempont. A Cargo nyilván tartja és rezolválja a Rust projektekben összeszedett függõségeket, illetve \textit{buildeli} a projektet. Két metadata fájlban tárolja a projekttel kap\-cso\-la\-tos információkat, melyek alapján beszerzi és buildeli a projekt függõségeit. Ezt követõen meghívja és futtatja a \texttt{rustc} fordítót a megfelelõ paraméterekkel. A Cargo a külsõ \textit{libraryket}, illetve függõségeket a \textit{crates.io} közösségi központi repozitóriumból szerzi be.

\subsection{A \texttt{minifb} könyvtár} 

\section{A feladat specifikációja}
