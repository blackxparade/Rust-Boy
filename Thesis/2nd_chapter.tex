\chapter{A fejlesztési folyamat}

Ahogy már az elõzõ fejezetekben is említésre került, az emulátor fejlesztõi szubkultúrában többé-kevésbé kialakult egyfajta irányelv, amit érdemes követni az emulátor fejlesztésénél. Természetesen olyan leírást nem lehet készíteni, ami bármilyen konzol emulátorának fej\-lesz\-té\-sé\-re használható -- a hardverek különbözõsége és a speciális megoldások nem teszik ezt lehetõvé. Azt viszont meg lehet tenni, hogy egy általános tervezési mintát meg\-ha\-tá\-ro\-zunk, és a tervezésnél, implementálásnál ezt követjük. \\
Az elsõ teendõ mindenképpen a lehetõ legtöbb tudásanyag összeszedése ilyen-olyan for\-rá\-sok\-ból: internetrõl, régi szaklapokból, esetleg magát a hardvert tanulmányozva. Nagy segítséget jelenthet például ha már valaki belekezdett ugyanazon hardver emulátorának fejlesztésébe, hiszen fontos információkkal szolgálhat. Egyes hardver emulátorok köré közösségek is összegyûlnek: így van ez a Game Boy esetén is. Ez a közösség egy honlapon gyûjtötte egybe az elérhetõ összes -- eddig fellelt -- információt a konzolról. A legfontosabb dokumentum azonban minden emulátor fejlesztése kapcsán a processzor dokumentációja, hiszen -- ahogy majd látjuk a késõbbiekben, erre ki is térek -- ezt fogjuk elõször imp\-le\-men\-tál\-ni. Mielõtt az implementációs szakaszba lépnénk, célszerû átgondolni az emulátor leendõ struktúráját, mûködését, illetve az alkalmazott eszközöket. Továbbá az elvárt mû\-kö\-dést, az \textit{inputot} és az \textit{outputot} is át kell gondolni a tényleges fejlesztési munkálatok elõtt.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth, trim={0 0.5cm 0 0.5cm},clip]{./Resources/v2/eps/emuarch.eps}
    \caption{\textit{Az emulátor architektúrája}}
    \label{fig:emuarch}
\end{figure}

\noindent A \ref{fig:emuarch}-es ábrán látható módon fog alakulni az emulátor felépítése, architektúrája. Ahogy az jól megfigyelhetõ, a CPU áll minden modul felett, ez tartalmazza a fõ ciklust is -- az idõzítõkkel és a megszakításvezérléssel egyetemben. A többi modul ehhez csatlakozva, de külön álló egységként képzelhetõ el. Ennek megfelelõen a fejlesztést a processzor megvalósításával kell kezdeni, majd a külön álló modulok imp\-le\-men\-tá\-lá\-sá\-val folytatni. Ezen részegységek fejlesztésének idõrendi sorrendje többnyire szabadon megválasztható, viszont célszerû a CPU - MMU - IRQ - PPU sorrendet követni. A 2.1-es alfejezetben lesz szó az emulátor ``magjáról'', a fõ ciklusról, amely a processzor (és így a többi modul) alapját képezi.

\section{A fõ ciklus}

A fõ ciklus a Game Boy utasítás-végrehajtását emulálja, aminek egy leegyszerûsített modellje bármilyen Neumann-elvû számítógép processzorára illeszkedni fog. Ezt a fõ ciklust elterjedtebb nevén \textbf{betöltõ-dekódoló-végrehajtó} ciklusnak is nevezik. Lépései a következõk\cite{Tanenbaum}:

\begin{enumerate}
  \item[(1)] A soron következõ utasítás betöltése a memóriából az utasításregiszterbe.
  \item[(2)] Az utasításszámláló (más néven \textit{Program Counter}, vagy PC) beállítása a következõ utasítás címére.
  \item[(3)] A beolvasott utasítás típusának meghatározása.
  \item[(4)] Ha az utasítás memóriabeli szót használ, a szó helyének meghatározása.
  \item[(5)] Ha szükséges, a szó beolvasása a CPU egy regiszterébe.
  \item[(6)] Az utasítás végrehajtása.
  \item[(7)] Vissza az 1. pontra.
\end{enumerate}

\noindent A fenti szerkezet valamilyen módon minden emulátorban megtalálható, ez a felépítés alapja. A ciklus addig ismétlõdik, amíg egy \texttt{HALT}, vagy egyéb kilépést/megállást szolgáló utasítás nem érkezik végrehajtásra. Természetesen a megszakításkezelõ valamelyest be\-le\-szól a ciklus mûködésébe, de errõl majd egy késõbbi fejezetben lesz szó. \\
A Game Boy emulátorban a fenti szerkezet egy egyszerûbb változata mûködik, ami váz\-lat\-sze\-rû\-en így néz ki:

\begin{minted}{rust}
loop {  // endless loop
  let next_byte = fetch_byte();
  let instruction = decode_instruction(next_byte);
  execute(instruction);
}
\end{minted}

\noindent A fenti függvényeket, és azok mûködését a késõbbiekben fogom részletezni.\\
A fõ ciklus megtervezése tipikusan a CPU alap struktúrájának (regiszterek, RAM, stb.) implementálása után következik. Ezek után jöhet csak a legtöbb emulátor leghosszabb és leg\-re\-pe\-titívebb része: a CPU mûveleteinek implementálása.

\section{Alkalmazott eszközök}

A fejlesztéshez alkalmazott eszközök meghatározása fontos tényezõ, hiszen nagyban meg\-könnyíthetjük vagy megnehezíthetjük a saját munkánkat. Elõször is célszerû egy prog\-ra\-mo\-zá\-si nyelvet választani, lehetõség szerint olyat, amihez léteznek olyan \textit{library}-k, amelyekkel megvalósítható a program. Emellett az is lényeges, hogy a programozási nyelv gyors binárist generáljon -- természetesen megvalósíthatjuk az emulátort \textit{Javascript} nyelven is, csak észrevehetõen lassabb lesz, mint mondjuk a \texttt{C++}-os variánsa. \\
A programozási nyelv mellett a \textit{debuggolást} nagyban megkönnyíti egy \textit{disassembler}, vagy optimális esetben egy másik emulátorhoz készített \textit{debugger}. A ROM fájlokhoz szükséges lehet még egy \textit{hex editor}\footnote{A \textit{hex editor} egy olyan szoftver, amely segítségével megtekinteni és módosítani lehet egy bináris adatfájlt. A ``\textit{hex}'' elõtag a hexadecimális rövidítésbõl ered: a bináris fájl bájtjait 16-os számrendszerben mutatja a program.}, hogy pontosan lássuk azt, hogy milyen bájtokkal dolgozunk. Ahhoz, hogy lássuk, a memóriában milyen adatok szerepelnek, célszerû egy me\-mó\-ri\-a\-tér\-kép eszközt készíteni a fejlesztés során. 

\subsection{A Rust programozási nyelv}
Az emulátor fejlesztéséhez a Rust programozási nyelvet választottam, több okból. Egy\-részt ez elõtt egy kisebb emulátor projekten dolgoztam a nyelvvel, és már akkor meg\-tet\-szett az egyszerûsége, a környezete, a nyelv köré alakult közösség. Másrészt a nyelvet az ehhez hasonló performancia-orientált feladatokra tervezték.\\
A \textbf{Rust} a fejlesztõk weboldala szerint egy 2006 óta fejlesztett, rendszerfejlesztésre ké\-szí\-tett nyelv, amely villámgyorsan dolgozik, megelõzi a szegmentációs hibákat, és ga\-ran\-tál\-tan gátolja a versenyhelyzetek kialakulását. Erõsen típusos nyelv, szintaktikailag a \texttt{C++}-hoz hasonlít, viszont hozzá képest biztonságosabb memóriakezelést biztosít a sebesség meg\-tar\-tá\-sá\-val. A Rust világában tehát nincsen \textit{null pointer}, lógó \textit{pointer}, és versenyhelyzet sem. A fejlesztését és tervezését a Mozilla kutatói részlege kezdte el, majd idõvel kö\-zös\-sé\-gi projektté alakult. Jelenleg \texttt{1.24.1}-es jelzésû az aktuális verzió. \cite{Rust} \\
Fontos még megemlíteni, hogy a \textit{Stack Overflow} weboldalon megrendezett éves fejlesztõi kérdõív kitöltések alapján 2016-ban, 2017-ben és 2018-ban is a Rust nyerte a ``leginkább kedvelt programozási nyelv'' kategóriát. Egyéb érdekesség, hogy jól megfigyelhetõ, hogy az emulátor fejlesztõ közösség túlnyomó többsége  \texttt{C++}-ban, vagy Rust-ban fejleszt -- ez a nyelv kényelmességének, eleganciájának és sokoldalúságának is köszönhetõ. \\
Maga a nyelv szépsége azonban még nem minden -- a nyelv mellett a \textbf{Cargo} eszköz egy fontos szempont. A Cargo nyilvántartja és rezolválja a Rust projektekben összeszedett függõségeket, illetve \textit{buildeli} a projektet. Két \textit{metadata} fájlban tárolja a projekttel kap\-cso\-la\-tos információkat, melyek alapján beszerzi és buildeli a projekt függõségeit. Ezt követõen meghívja és futtatja a \texttt{rustc} fordítót a megfelelõ paraméterekkel. A Cargo a külsõ \textit{libraryket}, illetve függõségeket a \textit{crates.io} közösségi központi repozitóriumból szerzi be. 

\subsection{A \texttt{minifb} könyvtár} 
Mivel grafikus programról beszélünk, ezért az ablakkezelés és az emulátor vizuális \textit{out\-put\-ja} fontos tényezõ. Ehhez -- ha lehetséges -- minél egyszerûbb és gyorsabb külsõ könyv\-tá\-rat kell használnunk, ha szeretnénk megkönnyíteni és felgyorsítani a mun\-ka\-fo\-lya\-ma\-tun\-kat. A \texttt{minifb} \textit{crate} ezt teszi lehetõvé, hiszen ez egy platformfüggetlen, Rust-ban írt \textit{library}, amivel az operációs rendszer által kínált natív ablakokat lehet megnyitni, és feltölteni egy 32 bites \textit{bufferrel}. Támogatja a billentyûzet és egér eseménykezelést, és némely operációs rendszer esetén (Windows, macOS) a menürendszereket. \\
A használata nagyon egyszerû\cite{minifb}: 

\begin{minted}{rust}
window : Window::new("RUST BOY",           // name
                     160,                  // width
                     144,                  // height
                     WindowOptions {       // other options
                         resize: false,
                         scale: Scale::X2,
                         ..WindowOptions::default()
                     }).unwrap()
}
\end{minted}
Amint látható, négy kötelezõen megadandó paramétere van a \texttt{Window} struktúra konst\-ruk\-to\-rá\-nak, me\-lyek rendre:

\begin{itemize}
  \item \texttt{name}: az ablak címsorában szereplõ szöveg,
  \item \texttt{width}: az ablak szélessége pixelben,
  \item \texttt{height}: az ablak magassága pixelben,
  \item \texttt{WindowOptions}: az egyéb ablakbeállításokat tartalmazó struktúra.
\end{itemize}

\noindent A negyedik paraméternél kiválaszthatjuk, hogy a \textit{default} ablakbeállításokat szeretnénk-e -- amennyiben igen, \texttt{WindowOptions::default()}-ot kell megadni. Ha saját be\-ál\-lí\-tá\-so\-kat kívánunk megadni ebben a \texttt{WindowOptions} struktúrában, rendre ezek közül választhatunk: 

\begin{itemize}
  \item \texttt{borderless}: ezzel megadható, hogy az ablaknak legyen-e kerete vagy sem,
  \item \texttt{title}: ezzel megadható, hogy az ablaknak legyen-e címe vagy sem,
  \item \texttt{resize}: ezzel megadható, hogy az ablak átméretezhetõ legyen-e vagy sem,
  \item \texttt{scale}: ezzel a struktúrával megadható, hogy az ablak mekkora nagyítással je\-len\-jen meg, választható opciók: \texttt{X1}, \texttt{X2}, \texttt{X4}, \texttt{X8}, \texttt{X16}, \texttt{X32}.
\end{itemize}

\noindent A konstruktor meghívását követõen az ablak tartalmát (és a \texttt{framebuffert}) a kö\-vet\-ke\-zõ\-kép\-pen frissíthetjük:

\begin{minted}{rust}
  window.update_with_buffer(&framebuffer).unwrap();
\end{minted}

\noindent ahol a \texttt{\&framebuffer} egy \texttt{\&[u32]} típusú, \texttt{u32} számokat tároló, \texttt{width * height} méretû tömbre mutató referencia. A tömbben lévõ számok tárolják el az adott pixel színét az ablakban: hexadecimálisan megadva az elsõ két karaktert figyelmen kívül hagyjuk, majd az utána következõ 6 karakter adja a szín hexadecimális megfelelõjét:
\begin{center}
  \textcolor{gray}{\texttt{FF}}
  \textcolor{red}{\texttt{FF}}
  \textcolor{green}{\texttt{FF}}
  \textcolor{blue}{\texttt{FF}} \\
\end{center}

\noindent A fentiek alapján látszik, hogy a második \textcolor{red}{\texttt{FF}} tag a piros (\texttt{R}), a harmadik \textcolor{green}{\texttt{FF}} tag a zöld (\texttt{G}), a negyedik \textcolor{blue}{\texttt{FF}} tag pedig a kék (\texttt{B}) színért felel. Külön-külön tehát az \texttt{RGB} kódokat, míg együtt a hexadecimális színkódot kapjuk. 

\subsection{Fejlesztõi környezet}
A fejlesztést \textit{elementary OS}\footnote{Az \textit{elementary OS} egy \textit{Ubuntu} alapú Linux disztribúció.} rendszeren végeztem. Az emulátor fejlesztés sajátosságai miatt feleslegesnek éreztem egy IDE\footnote{Az integrált fejlesztõi környezet (angolul IDE, azaz \textit{Integrated Development Environment}) a neve a számítógép-programozást jelentõsen megkönnyítõ, részben automatizáló programoknak.} használatát, hiszen ha a programkód szintaxisa megfelelõ, onnantól kezdve a hibakeresést az IDE-k által kínált eszközök sem tudják megkönnyíteni, ahhoz saját \textit{debuggert} kell írni. Ilyen fejlesztõi környezet használata he\-lyett tehát a klasszikusnak mondható szövegszerkesztõ (Atom, Rust \textit{linterrel}\footnote{Olyan eszközöket nevezünk \textit{linternek}, amelyek a forráskódot analizálva programozási hibákat, \textit{bugokat}, stílusbeli hibákat, vagy gyanús felépítéseket jeleznek a felhasználónak.}) és terminál párost használtam, a \texttt{rustc} fordító \textit{warningjaira} és \textit{errorjaira} hagyatkozva. \\
A \texttt{rustc} fordító \textit{targetjeként} a \texttt{stable-x86\_64-unknown-linux-gnu} beállítást használtam (alapbeállítás), ami a ``hagyományos'' 64 bites Linux disztribúciókra op\-ti\-ma\-li\-zált fordítási paraméterezés. A fordítást, futtatást és a külsõ függõségek (\textit{libraryk}) beszerzését a Cargo eszközzel valósítottam meg. 

\subsection{\textit{Debugger}}

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth, trim={0 14cm 0 0},clip]{./Resources/debugger.eps}
    \caption{\textit{Az emulátorhoz fejlesztett debugger}}
    \label{fig:debugger}
\end{figure}

\noindent Fontos eszköz volt a fejlesztés során a \textit{debugger}, amelyet az emulátorral pár\-hu\-za\-mo\-san fejlesztettem. Nagyon hasznos, hogy pontosan végig lehet követni az emulátor mûködését, és az egyes processzormûveletek után beállt állapotokat, hiszen ez nagyban megkönnyíti a hibakeresést. A \ref{fig:debugger}-es ábrán láthatjuk az eszközt mûködés közben: bal oldalon találhatóak a már elvégzett mûveletek, a jobb oldal pedig a regiszterek állapotát mutatja. \\
Az elvégzett mûveletek listájában legfelül a legutóbb végrehajtott mûvelet szerepel, a végén pedig a legrégebbi. A program az utolsó 50 állapotot tudja eltárolni, melyek közül az éppen kijelölt, aktív elemet piros kiemelés jelzi. Az egyes listaelemek az alábbi módon épülnek fel:

\begin{center}
  \colorbox{black}{\textcolor{DebuggerBlue}{\textbf{\texttt{0x21\;: LD HL,nn 0xFF 0xE6}}}} \\
\end{center}

\noindent A \texttt{0x21} jelzi az aktuális mûvelet \textit{opkódját}\footnote{Operációkód, azaz mûveleti kód, vagy mûveleti jelkód, utasításkészletek leírásában mûveleti jelrész. A CPU által beolvasott bináris szám, amit végrehajtható utasítás kódjaként értelmez.}, mellette szerepel a mûvelet \textit{mnemonikja}\footnote{A mnemonik az informatikában általában hosszabb elnevezésû mûvelet(sor) elnevezésére használatos rövidítés, amelyet az egész kifejezés helyettesítésére alkalmaznak, pl.: \texttt{ADD}, \texttt{SUB}.}, jelen esetben az \texttt{LD HL,nn}. A harmadik tag a mûvelet által beolvasott, és (o\-pe\-ran\-dus\-ként) felhasznált bájtokat tartalmazza, itt: \texttt{0xFF 0xE6}. A példában (és a \textit{debuggerben} is) be van színezve az utasítás -- ennek egyszerû oka van: az utasításokat kategóriákra bontottam, majd külön színeket rendeltem hozzájuk, így már ránézésre is meg lehet mon\-da\-ni, hogy milyen típusú mûveletrõl van szó. A mellékletként csatolt opkód táblázatban lévõ színek megegyeznek a \textit{debuggerben} látható színekkel. \\
A \textit{debugger} jobb oldalában foglal helyet a regiszterek nézete, itt található meg rendre az összes regiszter, a \textit{Stack Pointer}, és a \textit{Program Counter} értéke, valamint az \texttt{F} \textit{Flag} regiszter értéke binárisan -- hogy látható legyen az összes általa tartalmazott flag állapota. Ezen értékek annak függvényében változnak (és mutatják az aktuális értékeket), hogy épp melyik mûvelet van kijelölve.

\subsection{Memóriatérkép}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth, trim={0 1.7cm 0 0},clip]{./Resources/memorymap.eps}
    \caption{\textit{Az emulátorhoz fejlesztett memóriatérkép eszköz}}
    \label{fig:memorymap}
\end{figure}

\noindent A \textit{debugger} mellett a másik sokat használt eszköz a memóriatérkép. Ebben az ablakban megjelenik a Game Boy memóriájának összes bájtja, egy-egy pixel által reprezentálva. Az adott pixel világos, ha a bájt nulla, egyébként pedig sötétebb árnyalatú. A \ref{fig:memorymap}-as ábrán megfigyelhetõ, hogy többféle szín is megjelenik -- ezek jelölik az egyes fontosabb, elkülönülõ részeket a memóriában. A színeket is bevonva a reprezentációba a \textit{debuggerhez} hasonlóan ennél az eszköznél is ránézésre leolvashatók adatok. Ahhoz, hogy pontosan megtudjuk egy adott bájt értékét és pozícióját a memóriában, rá kell kattintani, és a terminál ablakban kiírásra kerülnek a szükséges információk. A kiírt adatok a következõ formában jelennek meg a terminál ablakban:

\begin{center}
  \texttt{BYTE: 0x46 0b01000110 -- POSITION: 0x7984} \\
\end{center}

\noindent Értelemszerûen a \texttt{BYTE} után szereplõ két szám az egérrel kijelölt bájt értékét mutatja, míg a \texttt{POSITION} után szerepel a bájt helye a memóriában. \\
A Game Boy architektúrájában gyakori, hogy egyes regiszterek a memóriában kapnak helyet -- errõl a késõbbiekben szó lesz --, és a memóriatérkép megoldással könnyedén meg lehet figyelni ezek értékeit, esetleg változásait. Emellett a dedikált és külön színnel kiemelt memória részeken látszik, hogy fel van-e töltve, vagy teljesen üres -- egy \textit{sprite} renderelési \textit{bug} kijavítását nagy mértékben megkönnyítette az, hogy látszott a me\-mó\-ri\-a\-tér\-ké\-pen a \textit{sprite}-ok hiánya. 

\section{A feladat specifikációja}
Az emulátornak a feladatkiírásban meghatározott feltételeket kell teljesítenie, azaz:
\begin{itemize}
  \item a CPU utasításokat és mûködését,
  \item a PPU renderelésének mûködését,
  \item a memóriakezelést,
  \item a megszakításvezérlést.
\end{itemize}

\noindent Ahhoz, hogy ezeket a feltételeket teljesíteni tudja, szükséges az \textit{input} és \textit{output} adatok (mûködés) pontos meghatározása. \\

\subsubsection{Az \textit{input} elvárt formai és tartalmi követelményei}
\noindent Az emulátor \textit{inputjaként} a Game Boy DMG\footnote{Az eredeti, klasszikus 1989-ben kiadott Game Boy kódneve DMG.} videojáték-konzolhoz írt videojátékok ROM-jait adhatjuk meg, illetve a visszafejtett Boot ROM-ot. Videojátékok esetén az emulátor csak az MBC (\textit{Memory Bank Controller}) nélküli ROM-okat képes futtatni. E\-lõ\-for\-dul\-hat\-nak olyan nem ismert, videojáték programozók által kihasznált \textit{bugok}, amelyek gátolják a ROM tökéletes futtatását. Szükséges hogy a ROM tartalmazza a \textit{headerjében} a Nintendo logó bájtjait (a Boot ROM-ban lévõ \textit{checksum} kiszámolja ezt), mert ellenkezõ esetben a játék nem fog elindulni. \\
Inputnak tekinthetõk még az emulált \textit{joypaden} történõ gombnyomások is, melyek hatással vannak az emulált szoftver mûködésére. A felhasználó egyszerre több gombot is le\-nyom\-hat -- ennek emulációja megfelel az eredeti hardverével. \\

\subsubsection{Az \textit{output} elvárt formai és tartalmi követelményei}
Az emulátor többféle \textit{outputot} is elõállít. A legfontosabb az emulált kijelzõre renderelt kép, amelynek meg kell egyeznie az eredeti konzol által kirajzolt képpel. A korhûség érdekében célszerû a 4-féle árnyalatot a konzol folyadékkristályos kijelzõjének jellegzetes zöld színeivel megegyezõ színekkel megjeleníteni. \\
Egyéb \textit{outputnak} tekinthetjük a \textit{debugger}, és a memóriatérkép által adott információkat is, hiszen az emulátor aktuális állapotáról adnak visszajelzéseket. Természetesen ezek elhanyagolhatóak, de a hibakeresést -- és így a fejlesztést -- segítik.