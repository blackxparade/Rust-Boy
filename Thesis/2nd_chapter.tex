\chapter{A fejlesztési folyamat}

Ahogy már az elõzõ fejezetekben is említésre került, az emulátor fejlesztõi szubkultúrában többé-kevésbé kialakult egyfajta irányelv, amit érdemes követni az emulátor fejlesztésénél. Természetesen olyan leírást nem lehet készíteni ami bármilyen konzol emulátorának fej\-lesz\-té\-sé\-re használható -- a hardverek különbözõsége és a speciális megoldások nem teszik ezt lehetõvé. Azt viszont meg lehet tenni, hogy egy általános tervezési mintát meg\-ha\-tá\-ro\-zunk, és a tervezésnél - implementálásnál ezt követjük. \\
Az elsõ teendõ mindenképpen a lehetõ legtöbb tudásanyag összeszedése ilyen-olyan for\-rá\-sok\-ból: internetrõl, régi szaklapokból, esetleg magát a hardvert tanulmányozva. Nagy segítséget jelenthet például ha már valaki belekezdett ugyanazon hardver emulátorának fejlesztésébe, hiszen fontos információkkal szolgálhat. Egyes hardver emulátorok köré közösségek is összegyûlnek: így van ez a Game Boy esetén is. Ez a közösség egy honlapon gyûjtötte egybe az elérhetõ összes -- eddig fellelt -- információt a konzolról. A legfontosabb dokumentum azonban minden emulátor fejlesztése kapcsán a processzor dokumentációja, hiszen -- ahogy majd látni a késõbbiekben erre ki is térek -- ezt fogjuk elõször implementálni. Mielõtt az implementációs szakaszba lépnénk, célszerû átgondolni az emulátor leendõ struktúráját, mûködését, illetve az alkalmazott eszközöket. Továbbá az elvárt mûködést, \textit{input}, \textit{output} adatokat is át kell gondolni a tényleges fejlesztési munkálatok elõtt.

\section{A fõ ciklus}

A fõ ciklus a Game Boy utasítás-végrehajtását emulálja, aminek egy leegyszerûsített modellje bármilyen Neumann-elvû számítógép processzorára illeszkedni fog. Ezt a fõ ciklust elterjedtebb nevén \textbf{betöltõ-dekódoló-végrehajtó} ciklusnak is nevezik. Lépései a következõk:

\begin{enumerate}
  \item A soron következõ utasítás betöltése a memóriából az utasításregiszterbe.
  \item Az utasításszámláló (másnéven \textit{Program Counter}, vagy PC) beállítása a következõ utasítás címére.
  \item A beolvasott utasítás típusának meghatározása.
  \item Ha az utasítás memóriabeli szót használ, a szó helyének meghatározása.
  \item Ha szükséges, a szó beolvasása a CPU egy regiszterébe.
  \item Az utasítás végrehajtása.
  \item Vissza az 1. pontra.
\end{enumerate}

\noindent A fenti szerkezet valamilyen módon minden emulátorban megtalálható, ez a felépítés alapja. A ciklus addig ismétlõdik, amíg egy \texttt{HALT}, vagy egyéb kilépést/megállást szolgáló utasítás nem érkezik végrehajtásra. Természetesen a megszakításkezelõ valamelyest be\-le\-szól a ciklus mûködésébe, de errõl majd egy késõbbi fejezetben lesz szó. \\
A Game Boy emulátorban a fenti szerkezet egy egyszerûbb változata mûködik, ami váz\-lat\-sze\-rû\-en így néz ki:

\begin{minted}{rust}
loop {  // endless loop
  let next_byte = fetch_byte();
  let instruction = decode_instruction(next_byte);
  execute(instruction);
}
\end{minted}

\noindent A fenti függvényeket, és azok mûködését a késõbbiekben fogom részletezni.\\
A fõ ciklus megtervezése tipikusan a CPU alap struktúrájának (regiszterek, RAM, stb.) implementálása után következik. Ezek után jön a legtöbb emulátor leghosszabb és leg\-re\-pe\-titívebb része: a CPU mûveleteinek implementálása. A mûveletek után a hard\-ver\-spe\-ci\-fi\-kus RAM mechanizmusokkal érdemes foglalkozni, majd a megszakításvezérlés, a grafikus emuláció és a joypad emuláció zárja a fejlesztést. Természetesen ez egy elnagyolt \textit{roadmap}, de mankónak, vezetõnek megfelelõ. 

\section{Alkalmazott eszközök}

A fejlesztéshez alkalmazott eszközök meghatározása fontos tényezõ, hiszen nagyban meg\-könnyíthetjük vagy megnehezíthetjük a saját munkánkat. Elõször is célszerû egy prog\-ra\-mo\-zá\-si nyelvet választani, lehetõség szerint olyat, amihez léteznek olyan \textit{library}-k, amelyekkel megvalósítható a program. Emellett az is lényeges, hogy a programozási nyelv gyors binárist generáljon -- természetesen megvalósíthatjuk az emulátort \textit{Javascript} nyelven is, csak észrevehetõen lassabb lesz, mint mondjuk a \textit{C++}-os variánsa. \\
A programozási nyelv mellett a \textit{debug}-olást nagyban megkönnyíti egy \textit{disassembler}, vagy optimális esetben egy másik emulátorhoz készített \textit{debugger}. A ROM fájlokhoz szükséges lehet még egy \textit{hex editor}\footnote{A \textit{hex editor} egy olyan szoftver, amely segítségével megtekinteni és módosítani lehet egy bináris adatfájlt. A "\textit{hex}" elõtag a hexadecimális rövidítésbõl ered: a bináris fájl bájtjait 16-os számrendszerben mutatja a program.}, hogy pontosan lássuk azt, hogy milyen bájtokkal dolgozunk. Ahhoz hogy lássuk, hogy a memóriában milyen adatok szerepelnek, célszerû egy memória térkép eszközt készíteni a fejlesztés során. 

\subsection{A Rust programozási nyelv}
Az emulátor fejlesztéséhez a Rust programozási nyelvet választottam, több okból. Egyrészt ez elõtt egy kisebb emulátor projekten dolgoztam a nyelvvel, és már akkor megtetszett az egyszerûsége, a környezete, a nyelv köré alakult közösség. Másrészt a nyelvet az ehhez hasonló performancia-orientált feladatokra tervezték.\\
A \textbf{Rust} a fejlesztõk weboldala szerint egy 2006 óta fejlesztett, rendszerfejlesztésre készített nyelv, amely villám gyorsan dolgozik, megelõzi a szegmentációs hibákat, és garantáltan gátolja a versenyhelyzetek kialakulását. Erõsen típusos nyelv, szintaktikailag a C++-hoz hasonlít, viszont hozzá képest biztonságosabb memóriakezelést biztosít a sebesség meg\-tar\-tá\-sá\-val. A Rust világában tehát nincsen null pointer, lógó pointer, és versenyhelyzet sem. A fejlesztését és tervezését a Mozilla kutatói részlege kezdte el, majd idõvel kö\-zös\-sé\-gi projektté alakult. Jelenleg \texttt{1.24.1}-es jelzésû az aktuális verzió. \\
Fontos még megemlíteni, hogy a \textit{Stack Overflow} weboldalon megrendezett éves fejlesztõi kérdõív kitöltések alapján 2016-ban, 2017-ben és 2018-ban is a Rust nyerte a "leginkább kedvelt programozási nyelv" kategóriát. Egyéb érdekesség, hogy jól megfigyelhetõ, hogy az emulátor fejlesztõ közösség túlnyomó többsége vagy C++-ban, vagy Rust-ban fejleszt -- ez a nyelv kényelmességének, eleganciájának és sokoldalúságának is köszönhetõ. \\
Maga a nyelv szépsége azonban még nem minden -- a nyelv mellett a \textbf{Cargo} eszköz egy fontos szempont. A Cargo nyilván tartja és rezolválja a Rust projektekben összeszedett függõségeket, illetve \textit{buildeli} a projektet. Két \textit{metadata} fájlban tárolja a projekttel kap\-cso\-la\-tos információkat, melyek alapján beszerzi és buildeli a projekt függõségeit. Ezt követõen meghívja és futtatja a \texttt{rustc} fordítót a megfelelõ paraméterekkel. A Cargo a külsõ \textit{libraryket}, illetve függõségeket a \textit{crates.io} közösségi központi repozitóriumból szerzi be. 

\subsection{A \texttt{minifb} könyvtár} 
Mivel grafikus programról beszélünk, ezért az ablakkezelés és az emulátor vizuális \textit{o\-ut\-put\-ja} fontos tényezõ. Ehhez -- ha lehetséges -- minél egyszerûbb és gyorsabb külsõ könyvtárat kell használnunk, ha szeretnénk megkönnyíteni és felgyorsítani a mun\-ka\-fo\-lya\-ma\-tun\-kat. A \texttt{minifb} \textit{crate} ezt teszi lehetõvé, hiszen ez egy platformfüggetlen, Rust-ban írt \textit{library}, amivel az operációs rendszer által kínált natív ablakokat lehet megnyitni, és feltölteni egy 32 bites \textit{bufferrel}. Támogatja a billentyûzet és egér eseménykezelést, és némely operációs rendszer esetén (Windows, macOS) a menürendszereket. \\
A használata nagyon egyszerû: 

\begin{minted}{rust}
window : Window::new("RUST BOY",           // name
                     160,                  // width
                     144,                  // height
                     WindowOptions {       // other options
                         resize: false,
                         scale: Scale::X2,
                         ..WindowOptions::default()
                     }).unwrap()
}
\end{minted}
Amint látható, négy kötelezõen megadandó paramétere van a \texttt{Window} struktúrának, me\-lyek rendre:

\begin{itemize}
  \item \texttt{name}: az ablak címsorában szereplõ szöveg,
  \item \texttt{width}: az ablak szélessége pixelben,
  \item \texttt{height}: az ablak magassága pixelben,
  \item \texttt{WindowOptions}: az egyéb ablakbeállításokat tartalmazó struktúra.
\end{itemize}

\noindent A negyedik paraméternél kiválaszthatjuk, hogy a default ablakbeállításokat szeretnénk-e -- amennyiben igen, \texttt{WindowOptions::default()}-ot kell megadni. Ha saját be\-ál\-lí\-tá\-so\-kat kívánunk megadni ebben a \texttt{WindowOptions} struktúrában, rendre ezek közül választhatunk: 

\begin{itemize}
  \item \texttt{borderless}: ezzel megadható, hogy az ablaknak legyen-e kerete vagy sem,
  \item \texttt{title}: ezzel megadható, hogy az ablaknak legyen-e címe vagy sem
  \item \texttt{resize}: ezzel megadható, hogy az ablak átméretezhetõ legyen-e vagy sem
  \item \texttt{scale}: ezzel a struktúrával megadható, hogy az ablak mekkora nagyítással jelenjen meg, választható opciók: \texttt{X1}, \texttt{X2}, \texttt{X4}, \texttt{X8}, \texttt{X16}, \texttt{X32}.
\end{itemize}

\noindent A konstruktor meghívását követõen az ablak tartalmát (és a \texttt{framebuffert}) a kö\-vet\-ke\-zõ\-kép\-pen frissíthetjük:

\begin{minted}{rust}
  window.update_with_buffer(&framebuffer).unwrap();
\end{minted}

\noindent ahol a \texttt{\&framebuffer} egy \texttt{\&[u32]} típusú, \texttt{u32} számokat tároló, \texttt{width * height} méretû tömbre mutató referencia. A tömbben lévõ számok tárolják el az adott pixel színét az ablakban: hexadecimálisan megadva az elsõ két karaktert figyelmen kívül hagyjuk, majd az utána következõ 6 karakter adja a szín hexadecimális megfelelõjét:
\begin{center}
  \textcolor{gray}{\texttt{FF}}
  \textcolor{red}{\texttt{FF}}
  \textcolor{green}{\texttt{FF}}
  \textcolor{blue}{\texttt{FF}} \\
\end{center}

\noindent A fentiek alapján látszik, hogy a második \textcolor{red}{\texttt{FF}} tag a piros (\texttt{R}), a harmadik \textcolor{green}{\texttt{FF}} tag a zöld (\texttt{B}), a negyedik \textcolor{blue}{\texttt{FF}} tag pedig a kék (\texttt{B}) színért felel. Külön-külön tehát az \texttt{RGB} kódokat, míg együtt a hexadecimális színkódot kapjuk. 

\subsection{Fejlesztõi környezet}
A fejlesztést \textit{elementary OS}\footnote{Az \textit{elementary OS} egy \textit{Ubuntu} alapú Linux disztribúció.} rendszeren végeztem. Az emulátor fejlesztés sajátosságai miatt feleslegesnek éreztem egy IDE\footnote{Az integrált fejlesztõi környezet (angolul IDE, azaz Integrated Development Environment) a neve a számítógép-programozást jelentõsen megkönnyítõ, részben automatizáló programoknak.} használatát, hiszen ha a programkód szintaxisa megfelelõ, onnantól kezdve a hibakeresést az IDE-k által kínált eszközök sem tudják megkönnyíteni, ahhoz saját \textit{debuggert} kell írni. Ilyen fejlesztõi környezet használata helyett tehát a klasszikusnak mondható szövegszerkesztõ (Atom, Rust \textit{linterrel}\footnote{Olyan eszközöket nevezünk \textit{linternek}, amelyek a forráskódot analizálva programozási hibákat, \textit{bugokat}, stílusbeli hibákat, vagy gyanús felépítéseket jeleznek a felhasználónak.}) és terminál párost használtam, a \texttt{rustc} fordító \textit{warningjaira} és \textit{errorjaira} hagyatkozva. \\
A \texttt{rustc} fordító \textit{targetjeként} a \texttt{stable-x86\_64-unknown-linux-gnu} beállítást használtam (alapbeállítás), ami a "hagyományos" 64 bites Linux disztribúciókra op\-ti\-ma\-li\-zált fordítási paraméterezés. A fordítást, futtatást és a külsõ függõségek (\textit{libraryk}) beszerzését a Cargo eszközzel valósítottam meg. 

\subsection{\textit{Debugger}}


\section{A feladat specifikációja}
