\chapter{A processzor és a memória implementációja}

\begin{wrapfigure}{l!}{\textwidth/2}
    \centering
    \includegraphics[width=\textwidth/2-0.5cm, trim={2cm 2.5cm 2cm 5.5cm},clip]{./Resources/cpu.eps}
    \caption{\textit{A Game Boy szabadalmában ábrázolt processzor felépítés}}
    \label{fig:patentcpu}
\end{wrapfigure}

A korábban írtaknak megfelelõen az implementációt a processzorral és a me\-mó\-ri\-á\-val kezdjük -- a megfelelõ tudásanyag birtokában a processzor felépítésének modellezése az elsõ feladat. Fontos már a korai tervezési folyamatoktól kezdve szem elõtt tartani a belsõ felépítés modelljét, és ennek tudatában úgy alakítani az implementálást, hogy egyrészt az eredeti hardverrel nagyrészt megegyezõ módon mûködjön (és épüljön fel), másrészt a további modulok, egységek és funkciók jól illeszkedjenek ehhez a fõ komponenshez. Ehhez nyújt nagy segítséget a Nintendo által bejegyzett Game Boy szabadalomban ábrázolt felépítés, amit a \ref{fig:patentcpu}-es ábrán figyelhetünk meg. Jól látszik a processzor és a memória kapcsolata, illetve ez elõbbi felépítésébe is nyújt némi betekintést, utóbbinak egyes részeit pedig már ezen az ábrán is láthatjuk, a késõbbiekben ezt jobban meg is vizsgáljuk. Az elõzõ fejezetben ismertetett betöltõ-dekódoló-végrehajtó ciklust alkotó elemek közül is megfigyelhetjük az utolsó kettõt. A hardver teljes felépítésérõl tágabb képet kaphatunk, ha megfigyeljük a 4. fejezetbeli függelék \ref{fig:architecture}-es ábráját, amely szintén a Nintendo által benyújtott szabadalom része. Ez az ábra késõbb nagy se\-gít\-sé\-günk\-re lesz a modulok felépítésének, és a rendszer struktúrájának implementálása során, hiszen elég részletesen mutatja be az egyes elemek közti kapcsolatokat, kommunikációt.

\section{CPU}
\subsection{Regiszterkészlet}
Ahogy az elsõ fejezetben már említésre került, a Game Boy-ban egy \textit{Zilog Z80} alapú, \textit{Sharp LR35902} típusú 8 bites processzor dolgozik. A \textit{Z80}-hoz képest annyi változás történt, hogy a regiszterek elrendezését a \textit{Sharp} mérnökei az \textit{Intel 8080}-as processzortól vették kölcsön, illetve több utasítást is kivettek, helyükre sajátokat téve. \\
A \ref{fig:patentcpu}-es ábrán látható, hogy a processzor nyolc darab 8 bites, és két darab 16 bites regiszterrel rendelkezik. A 8 bitesek név szerint: \texttt{A}, \texttt{F}, \texttt{B}, \texttt{C}, \texttt{D}, \texttt{E}, \texttt{H}, \texttt{L}, míg a 16 bitesek a \texttt{PC} és az \texttt{SP}. A 8 bites regiszterek felsorolásának sorrendje nem véletlen: a CPU egyik igen hasznos funkciója az, hogy regisztereket tud összevonni, két 8 bitesbõl 16 biteseket varázsolva -- így ezekben a nagyobb regiszterekben el lehet tárolni memóriacímeket, vagy egyéb 16 bites adatokat. Az összevont regiszterek rendre: \texttt{AF}, \texttt{BC}, \texttt{DE}, \texttt{HL}. \\
Az \texttt{A} regiszter hagyományosan az akkumulátorregiszter\footnote{Olyan regiszter, amiben az aritmetikai-logikai egység által végzett mûveletek operandusai, illetve az eredmény átmenetileg tárolódik.}, míg az \texttt{F} tárolja a \textit{flageket}.

\begin{table}[h!]
  \centering
  \begin{tabular}{ |c|c|c|c|c|c|c|c| } 
   \hline
   \rowcolor{GameBoyBlue} 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0  \\ 
   \hline
   Z & S & H & C & 0 & 0 & 0 & 0 \\ 
   \hline
  \end{tabular}
  \caption{\textit{Az} \texttt{F} \textit{Flag regiszter bitjei}}
  \label{table:1}
\end{table}

\noindent A \ref{table:1}-es táblázatról leolvashatók az \texttt{F} regiszter \textit{flagjeinek} helyzete. A rövidítések je\-len\-té\-se\-i a kö\-vet\-ke\-zõk:

\begin{itemize}
  \item \textit{Z}: \textit{Zero Flag}, értéke akkor 1, ha valamilyen logikai vagy aritmetikai mûvelet e\-red\-mé\-nye 0.
  \item \textit{S}: \textit{Subtract Flag}, értéke akkor 1, ha valamilyen kivonás mûveletet végzett a pro\-cesszor.
  \item \textit{H}: \textit{Half Carry Flag}, értéke akkor 1, ha valamilyen logikai vagy aritmetikai mûvelet során az akkumulátorregiszter alsó 4 bitjén túlcsordulás vagy alulcsordulás ke\-let\-ke\-zett.
  \item \textit{C}: \textit{Carry Flag}, értéke akkor 1, ha valamilyen logikai vagy aritmetikai mûvelet során az akkumulátorregiszteren túlcsordulás vagy alulcsordulás ke\-let\-ke\-zett. Nem összekeverendõ a \textit{Half Carry Flaggel}.
\end{itemize}
Az alsó 4 bit használaton kívüli, mindig 0. Ezeket a \textit{flageket} a processzor utasításai vezérlik a mûvelet kimenetelétõl függõen. Az emulátor fejlesztése szempontjából ez egy kritikus pont -- a \textit{flagek} pontos emulációján nagyon sok múlik, elképesztõ mennyiségû hibakeresést spórolhatunk meg magunknak azzal ha odafigyelünk az implementációkor. Érdemes készíteni a \texttt{CPU} struktúrába \textit{flag} beállító és lekérdezõ függvényeket is az u\-ta\-sí\-tá\-sok implementálásához. \\
A két 16 bites regiszter szerepe megegyezik ehhez hasonló architektúrákban ta\-pasz\-tal\-tak\-hoz: a \texttt{PC}, azaz \textit{Program Counter} azt mutatja, hogy a processzor hol tart az utasítási sorban (a memóriában), míg az \texttt{SP}, vagy \textit{Stack Pointer} mutatja a hívási verem (\textit{Call Stack}) aktuális címét, azaz hogy éppen hol helyezkedik el a memóriában a verem legfelsõ eleme. Érdemes megjegyezni, hogy a verembe pakoláskor -- azaz a \texttt{PUSH} mûvelet hívásakor -- a verem új, legfelsõ elemét a memóriában lefelé haladva szúrjuk be, azaz a legkisebb memória címû verembeli elem képzi a verem tetejét. \\
Ami az implementációt illeti, a 8 bites regisztereket 8 bites \textit{Unsigned Integerként}, azaz \texttt{u8}-ként, a 16 biteseket pedig \texttt{u16}-ként deklaráltam, hiszen negatív értéket nem fog felvenni egyik regiszter sem. A processzort modellezõ struktúra tehát ilyen módon fog kinézni: \\
\begin{minted}{rust}
pub struct CPU {
    pub A : u8,
    pub B : u8,
    pub C : u8,
    pub D : u8,
    pub E : u8,
    pub F : u8,
    pub H : u8,
    pub L : u8,
    pub SP : u16,
    pub PC : u16,
    pub RAM : [u8; 65536],
}
\end{minted}

\subsection{Ciklusok, frekvenciák}
A Nintendo Game Boy processzorának frekvenciája 4.194304 MHz. Azonban az egész rendszer a memóriához kötött, tulajdonképpen a memória elérésének sebessége meg\-ha\-tá\-roz\-za az összes egység sebességét is. Jelen esetben a memória az architektúra szûk keresztmetszete, ugyanis \url{~}1 MHz sebességgel mûködik. A hardver egyes kom\-po\-nen\-se\-i\-nek sebessége az alábbiak szerint alakul:

\begin{table}[h!]
  \centering
  \begin{tabular}{ |>{\columncolor{GameBoyBlue}}l|c| } 
   \hline
   CPU \; & \; 4,194,304 Hz\; = \;\url{~}4 MHz \; \\ \hline
   RAM \; & \; 1,048,576 Hz\; = \;\url{~}1 MHz \; \\ \hline
   PPU \; & \; 4,194,304 Hz\; = \;\url{~}4 MHz \; \\ \hline
   VRAM \; & \; 2,097,152 Hz\; = \;\url{~}2 MHz \; \\ \hline
  \end{tabular}
  \caption{\textit{A Game Boy fõ elemeinek sebessége}}
  \label{table:2}
\end{table}

\noindent A fenti \ref{table:2}-es táblázaton látható, hogy az alkotóelemek sebességei nem egységesek, vi\-szont hiába gyors a processzor, ha a memória visszafogja a rendszert. Így praktikussági okokból kétféle ciklust különböztetünk meg: 

\begin{itemize}
  \item az \textit{órajel ciklust}, ami a specifikációban írt 4,194,304 Hz (azaz 4 MHz)-nek felel meg,
  \item és az \textit{gépi ciklust}, ami megegyezik a RAM frekvenciájával, így 1,048,576 Hz (azaz 1 MHz) lesz.
\end{itemize}

\noindent Ettõl a ponttól kezdve az utasítások idõzítését gépi ciklus szerint tekintjük, és a ciklus kifejezés alatt a gépi ciklust értjük. Az oka ennek az, hogy az 1 MHz-es gépi ciklus minden komponens sebességére visszavezethetõ, egyfajta közös nevezõnek tekinthetõ.

\subsection{Betöltés - dekódolás - végrehajtás}

A betöltés-dekódolás-végrehajtás ciklus függvényeit az \texttt{Opcode} struktúra tartalmazza. A betöltést a \texttt{fetch} függvény valósítja meg, amely visszatér a CPU RAM-ot reprezentáló tömbjének \texttt{PC} regiszter értékével megegyezõ indexû elemével (amely \texttt{u8} típusú). A de\-kó\-do\-lás és a végrehajtás mûveletek az \texttt{execute} függvényben történnek. A \texttt{fetch} által visszatért bájt dekódolása úgy történik, hogy az \texttt{Opcode} struktúra rendelkezik egy \texttt{opc} és egy \texttt{cb\_opc} tömbbel, a processzor mûveletet azonosító bájtot átadjuk az \texttt{opc} tömb számára, mint tömbindex. Az \texttt{opc} és a \texttt{cb\_opc} tömbök rendre 256 elemûek, és függ\-vé\-nyek\-re mutató pointereket tartalmaznak, így a bájt tömbindexként való használatával meghívható az adott opkódhoz tartozó utasítást megvalósító függvény. \\
Amennyiben \texttt{CB} prefixû opkód az aktuális utasítás, úgy elõször az \texttt{opc[0xCB]} által mutatott függvény hívódik meg, amely meghívja a \texttt{fetch} függvényt, hogy az betöltse a \texttt{CB} prefixû táblán értelmezett mûvelet opkódját. Ugyaninnen hívódik meg a konkrét mûveletet megvalósító függvény a \texttt{cb\_opc} függvény pointer tömb használatával. \\
A processzor mûveleteit megvalósító függvények visszatérési értéke egy \texttt{u8} szám, amely azt mutatja, hogy a konkrét mûvelet teljes végrehajtása hány processzor ciklus alatt tör\-té\-nik meg. Az \texttt{Opcode} struktúra \texttt{execute} függvénye ezt az értéket szintén visszatértési értékként fûzi tovább. \\
A processzor a fenti mûveleteket hívja meg a ciklus minden egyes iterációjában, majd a mûveletek által visszaadott mûveleti ciklus értékeket összeadva szinkronizálja össze a mûvelet végrehajtást a \textit{rendereléssel}. A 60 FPS\footnote{\textit{Frames Per Second}, azaz képkocka per másodperc -- a \textit{renderelés} frissítési gyakoriságát megadó mértékegység.} renderelési sebességet céloztam meg, amely az eredeti konzol képernyõfrissítési értékével is nagyságrendileg megegyezik. A \textit{renderelés} ideje így a következõ számítás alapján megkapható:
$$ 4194304/60 = 69905,$$
ahol a 4194304-es érték a processzor órajel ciklusa, a 60 jelzi az FPS értéket, a vég\-e\-red\-mény pedig megmutatja, hogy mekkora összegig kell folytatni a processzor mûveleteinek vég\-re\-haj\-tá\-sát. A fõ ciklus sémája kiegészítve a szinkronizált PPU \textit{rendereléssel} tehát így alakul:

\begin{minted}{rust}
loop {  // endless loop
  while cycle <= 69905 {
    cycle += opcode.execute();
  }
  ppu.render();
}
\end{minted}

\section{Interrupt kezelés}
Az utasításkészlet részletes bemutatása elõtt fontos szót ejteni a Game Boy \textit{interrupt} kezelésérõl -- több utasítás kapcsán is elõ fog jönni ez a téma. \\
Adott események bekövetkezése (ez hardverenként eltér) \textit{interruptot}, vagy \textbf{megszakítást} vált ki, ezzel kényszeríti a CPU-t, hogy az éppen futó programot azonnal felfüggessze, és egy speciális eljárást, a \textbf{megszakításkezelõt} végrehajtsa, amely a hibaellenõrzést és egyéb speciális teendõket elvégezve értesíti a vezérlõt, hogy a megszakítás befejezõdött.\cite{Tanenbaum} \\
A Nintendo Game Boy architektúrájában kétféle megszakítást különböztetünk meg: létezik szoftveres, és hardveres megszakítás is. Ami a szoftveres megszakításokat illeti, ezeket a hardver programozói használhatták, az egyes \texttt{RST} (a \texttt{RESET} rövidítése) mûveletekkel lehet elõre definiált memóriacímekre ugrani. A hardveres megszakítások témaköre már kicsit bonyolultabb. \\
Alapvetõen 5 féle hardveres megszakítást különböztetünk meg:
\begin{itemize}
  \item \textit{V-Blank}: A képernyõ frissítése során periodikusan elõidézett megszakítás, a ké\-sõb\-bi\-ek\-ben -- a PPU-t taglaló fejezetben -- részletesebben is szó lesz róla. 
  \item \textit{LCD STAT}: Többféle esemény is elõidézheti ezt a típusú megszakítást, az egyik leggyakoribb ezek közül az, amikor a hardver egy adott sor újrarajzolásánál tart az LCD kijelzõn.
  \item \textit{Timer}: Akkor következik be ez a megszakítás, amikor a \texttt{TIMA} idõzítõ regiszter túlcsordul. A késõbbiekben erre is kitérek.
  \item \textit{Serial}: A hardveren található soros port mûködése közben következik be a \textit{Serial} megszakítás, ha egy konkrét adatátvitel befejezõdött. Ezen emulátor esetében ezt a megszakítást nem implementáltam.
  \item \textit{Joypad}: Ez a megszakítás bármelyik hardveres gomb lenyomásakor aktiválódik.
\end{itemize}

\noindent A megszakításokhoz a CPU kapcsán három dolog köthetõ a fentieken kívül. Egy fõ interrupt kapcsoló, az \textit{Interrupt Master Enable Flag}, amivel le lehet tiltani, vagy éppen engedélyezni lehet a megszakításokat \textit{en bloc}, egy ún. \textit{Interrupt Enable} regiszter, ahol külön-külön lehet engedélyezni vagy letiltani az egyes megszakításokat, illetve egy \textit{Interrupt Flag} regiszter, amiben a megszakítási sorban várakozó, még (a CPU által) teljesítetlen megszakítások szerepelnek.


\begin{table}[h!]
  \centering
  \begin{tabular}{
  |>{\columncolor{GameBoyBlue}} l | l
  |>{\columncolor{GameBoyDarkBlue}} c
  |>{\columncolor{GameBoyBlue}} l | l |}
  \hline
    \textbf{\texttt{0xFFFF}} & \cellcolor{GameBoyBlue}Interrupt Enable & \textcolor{white}{Jump Location} & \textbf{\texttt{0xFF0F}} & \cellcolor{GameBoyBlue}Interrupt Flag \\ \hline
    4 & \textit{Joypad} & \textcolor{white}{\texttt{0x60}} & 4 & \textit{Joypad} \\ \hline
    3 & \textit{Serial} & \textcolor{white}{\texttt{0x58}} & 3 & \textit{Serial} \\ \hline
    2 & \textit{Timer} & \textcolor{white}{\texttt{0x50}} & 2 & \textit{Timer} \\ \hline
    1 & \textit{LCD STAT} & \textcolor{white}{\texttt{0x48}} & 1 & \textit{LCD STAT} \\ \hline
    0 & \textit{V-Blank} & \textcolor{white}{\texttt{0x40}} & 0 & \textit{V-Blank} \\ \hline
  \end{tabular}
  \caption{\textit{Az Interrupt Enable és az Interrupt Flag regiszterek megszakítások szerinti bit kiosztása, és a hozzájuk tartozó memóriacímek}}
  \label{table:3}
\end{table}

\noindent Elõfordulhat, hogy egyszerre több megszakítás érkezik. Ebben az esetben a prioritási sorrend az \textit{Interrupt Flag} regiszterben elfoglalt helyek alapján alakul: a \textit{V-Blank interrupt} a legfontosabb, míg a \textit{Joypad} megszakítás marad utoljára. Miután a prioritás alapján a megszakításvezérlõ kiválasztotta, hogy melyik megszakítás következzen, a \ref{table:3}-as táblázaton szereplõ adatoknak megfelelõen az adott megszakításhoz tartozó memóriacímre ugrik a vezérlés. \\
Ami az implementálást illeti, a megszakítás vezérlõ feladatait az \texttt{Interrupt} struktúra, és annak függvényei látják el. Az \texttt{IRQ} függvény segítségével tudnak az egyes modulok (PPU, idõzítõ, stb.) megszakítást kérni, melyet aztán a \texttt{handler} függvény dolgoz fel. A feldolgozás oly módon történik, hogy minden CPU mûvelet után a fõ ciklusban meghívódik az \texttt{interrupt\_checker} függvény, amely folyamatosan ellenõrzi, hogy érkezett-e új megszakítás, és hogy az engedélyezve van-e az \textit{Interrupt Enable} regiszterben 
 -- ha igen, akkor a megszakítás azonosítóját paraméterként átadva meghívja a \texttt{handler} függvényt, amely a megszakításhoz tartozó memóriacímre ugrasztja a CPU-t.

\section{Utasításkészlet}

Ahogy azt már az elõzõ alfejezetben ismertettem, az \texttt{Opcode} struktúrában implementált processzor mûveletek visszatérési értéke egy \mintinline{rust}{u8} típusú egész szám, amely a mûvelet végrehajtási idejével lesz egyenlõ. Azt azonban még nem ismertettem, hogy hogyan néz ki egy utasítás sematikusan.

\begin{minted}{rust}
fn opcode_name_ff(&mut self, cpu : &mut CPU) -> u8 {
        //...
        4
}
\end{minted}

\noindent A fenti kódrészleten látható, hogy az egyes utasítások függvényeinek neve tartalmazza az utasítás nevét -- \textit{mnemonik} vagy bõvebb alakban --, illetve az \textit{opkódját}. A paraméterlistában szerepel a \mintinline{rust}{&mut self} paraméter, amely a Rust nyelvben azt jelenti, hogy az adott függvény egy osztályfüggvény, és hogy módosíthatja az osztályt reprezentáló objektumot. A második paraméter (\mintinline{rust}{&mut CPU}) pedig a fõ \mintinline{rust}{CPU} struktúrára mutató \textit{mutable} referencia, azaz olyan \mintinline{rust}{cpu} objektumot kapunk, amely módosítható -- Rust nyelven \textit{borrow}-oltuk, azaz kölcsön kaptuk az objektumot. \\
Sok esetben elõfordul, hogy egy mûvelet egy vagy két operandussal rendelkezik, melyeket külön be kell tölteni a memóriából. Ezt a mûvelet függvényén belül tesszük meg a \mintinline{rust}{fetch} metódus meghívásával.

\subsection{\textit{Load} utasítások - \texttt{LD}}

A \textit{Load}, azaz betöltõ mûveletek legnagyobb része nagyon egyszerûen mûködik: adott két regiszter -- a példánkban legyen ez most \texttt{X} és \texttt{Y} --, ekkor a mûvelet így alakul:

\begin{minted}{asm}
                          LD X,Y
\end{minted}

\noindent Ez triviálisan az \texttt{Y} regiszter értékét tölti be az \texttt{X} regiszterbe - ennek megvalósítása tu\-laj\-don\-kép\-pen egy egyszerû kifejezés. Fontos hozzátenni, hogy az \texttt{Y} helyén állhat egy bájt is. Egyik \textit{Load} mûvelet sem befolyásolja a \textit{flagek} állapotát. \\
A továbbiakban ismertetésre kerülnek a fenti alapesettõl eltérõ betöltõ utasítások.

\subsubsection{Beltöltés memóriacímrõl, vagy memóriacímre}
A \textit{Load} mûveletek másik típusa esetén az \texttt{X} vagy \texttt{Y} regiszter helyett állhat memóriacím is. A cím értéke átadható \texttt{(HL)} összevont regiszter formában: \mintinline{asm}{LD A,(HL)}, vagy két külön betöltött bájt összevonásaként: \mintinline{asm}{LD A,(0x2f44)}.

\subsubsection{A \textit{Stack Pointer} betöltõje}
A \textit{Stack Pointer} betöltése a \texttt{HL} regiszterpárba az elõzõhekhez képest bonyolultabb mûvelet. Egyetlen paraméterébeb várja azt a \textit{signed}, tehát elõjeles(!) értéket, amely a betöltendõ memóriahely címének távolságát mutatja az \texttt{SP} regiszterhez képest. A \texttt{fetch} függvénnyel betöltött bájtot elõször \textit{castolni} kell \mintinline{rust}{i8} típusúra, majd az elõjel vizsgálatát követõen betölteni az adatot a \texttt{HL}-be a megfelelõ helyrõl. A mûvelet az alábbiak szerint néz ki:
\begin{minted}{asm}
                        LDHL SP,0x42
\end{minted}

\subsubsection{Egyéb speciális betöltõk}
Több speciális betöltõ mûvelet is elérhetõ, ezeket a fentiekhez való hasonlóságuk miatt csak felsorolásszerûen fogom ismertetni:

\begin{itemize}
  \item \mintinline{asm}{LD A,(C)}: ezzel a mûvelettel a \textit{High RAM} részre tudunk írni -- a \texttt{C} regiszter értékéhez hozzáadódik még a \texttt{0xFF00} cím, ezzel megkapva a pontos címet. Fordított operandusokkal is mûködik.

  \item \mintinline{asm}{LDH A,(0x42)}: az elõzõhöz hasonló mûvelet, annyi különbséggel, hogy itt a \texttt{C} regiszter helyett paraméterben megadható az \texttt{0xFF00}-hez mért eltolás értéke. Fordított operandusokkal is mûködik.

  \item \mintinline{asm}{LD A,(HL}\texttt{+)}: a \texttt{HL} értékének megfelelõ memóriahely \texttt{A} regiszterbe töltése után inkrementálja a \texttt{HL} értékét eggyel. Fordított operandusokkal is mûködik.

  \item \mintinline{asm}{LD A,(HL}\texttt{-)}: az elõzõvel megegyezõ módon mûködik, inkrementálás helyett dekrementálással.
\end{itemize}

\subsection{Aritmetikai utasítások - \texttt{ADD, ADC, SUB, SBC, INC, DEC}}

Az aritmetikai utasítások alatt ezen az architektúrán az összeadás, kivonás, inkrementálás és dekrementálás mûveleteket értjük. Ezek lényegi mûködése persze triviális, viszont a mûveletek hatása a \textit{flag} regiszterre fontos tényezõ, így ezt célszerû részletesebben meg\-vizs\-gál\-ni. Külalakukban megegyeznek, példaként szerepeljen az összeadás szintaxisa:
\begin{minted}{asm}
                           ADD A,B
\end{minted}
amely értelemszerûen az \texttt{A} regiszter értékét teszi egyenlõvé az \texttt{A} és \texttt{B} regiszterek értékeinek összegével.

\subsubsection{Összeadás}
Két típusú összeadást megvalósító mûvelet áll a programozók rendelkezésére: az \mintinline{asm}{ADD}, és az \mintinline{asm}{ADC}. Ezen utasítások esetében közös probléma a túlcsordulás -- hogyan kezeljük ha az összeg nagyobb, mint 255, azaz nem fér bele az \mintinline{rust}{u8} adattípusba? Szerencsére a Rust nyelv biztosít erre egy olyan megoldást, amely a hardver viselkedésével megegyezik. A két \mintinline{rust}{u8} típusú operandust nem a hagyományos módon (\mintinline{rust}{u8} + \mintinline{rust}{u8}) adjuk össze, hanem a \mintinline{rust}{wrapping_add} függvény segítségével a következõ módon:
\begin{minted}{rust}
  let a : u8 = 5;
  let b : u8 = 6;
  println!("{}", a.wrapping_add(b)); // Output: 11
\end{minted}

\noindent A fenti függvény abban az esetben, ha az összeg nagyobb lenne, mint 255, körbe \textit{wrappeli} az eredményt, azaz elvégez egy$\mod 256$ mûveletet az összegen. Így a túlcsordulás problémáját sikerült kiküszöbölni, az összeadás bármely értékekkel elvégezhetõ úgy, hogy biztosan nem lépünk ki az adattípus méretébõl. \\
Ami a \textit{flageket} illeti, az összeadások esetében mindegyikük érintett: 
\begin{itemize}
  \item \texttt{Z}: állítsuk be 1-re, ha az összeg értéke 0, egyébként legyen az új értéke 0,
  \item \texttt{N}: mivel nem kivonásról van szó, az értékét állítsuk 0-ra,
  \item \texttt{H}: ha \textit{half-carry} történik, állítsuk 1-re, egyébként 0-ra,
  \item \texttt{C}: ha túlcsordulás történik, állítsuk 1-re, egyébként 0-ra.
\end{itemize}
A \textit{half-carry} avagy fél-túlcsordulás detektálása a következõ képpen történik:
\begin{minted}{rust}
  if (a & 0xF) + (b & 0xF) > 0xF {
      cpu.set_flag("H");
  } else {
      cpu.reset_flag("H");
  }
\end{minted}
Látható, hogy az elágazás logikai kifejezésének bal oldalán a két operandus értékének vesszük külön-külön az alsó 4 bitjét (\mintinline{rust}{a & 0xF},\;  \mintinline{rust}{b & 0xF}), majd ha azok összege nagyobb, mint 15 (binárisan \texttt{00001111}), akkor fél-túlcsordulás következett be. Ekkor állítsuk a \texttt{H} \textit{flaget} 1-re, egyébként pedig 0-ra. \\
A \texttt{C}-vel jelölt túlcsordulás ellenõrzése triviális. \\
A különbség az \mintinline{asm}{ADD}, és az \mintinline{asm}{ADC} mûveletek között az, hogy -- mint az a \textit{mnemonikból} is kikövetkeztethetõ -- az \mintinline{asm}{ADC} az egyszerû összeadás mellett az összeghez hozzáadja a \texttt{C} \textit{flag} értékét is (\textit{ADD with Carry}). A \textit{flag} értékének hozzádását szintén a \mintinline{rust}{wrapping_add} függvénnyel tesszük.

\subsubsection{Kivonás}

A \mintinline{asm}{SUB}, és az \mintinline{asm}{SBC} kivonás mûveletek nagyon hasonlóak a fentebb részletezett összeadás mûveletekhez, természetesen kivonásos formában. \texttt{wrapping\_add} függvény helyett \texttt{wrapping\_sub} függvényt használunk, amely negatív különbség esetén a másik irányba \textit{wrappeli} át a végeredményt, szintén a$\mod 256$ számítást alkalmazva. \\
A \textit{flagek} az összeadás mûveletekhez képest a következõképpen alakulnak:
\begin{itemize}
  \item \texttt{Z}: megegyezik az összeadásnál ismertetettel,
  \item \texttt{N}: ebben az esetben kivonásról van szó, így az értéke legyen 1,
  \item \texttt{H}: megegyezik az összeadásnál ismertetettel,
  \item \texttt{C}: ha alulcsordulás történik, állítsuk 1-re, egyébként 0-ra.
\end{itemize}
A \textit{half-carry flag} beállítása megegyezik ugyan az összeadásnál tapasztalttal, viszont a detektálása más módon történik:
\begin{minted}{rust}
  if (a & 0x0F) < (b & 0x0F) {
      cpu.set_flag("H");
  } else {
      cpu.reset_flag("H");
  }
\end{minted}
Az elágazás feltételes logikai kifejezésében láthatjuk, hogy a két operandus alsó 4 bitjeit hasonlítjuk össze egymással. Ha a kivonandó ilyen módon nagyobb mint a kisebbítendõ, akkor fél-alulcsordulás történik -- ekkor állítjuk 1-re a megfelelõ bitet, egyébként pedig 0-ra.\\
Alulcsordulás akkor történik, ha a különbség kisebb, mint 0. \\
Az \mintinline{asm}{SBC} mûvelet ebben az esetben is annyiban különbözik a hagyományos kivonástól, hogy a \texttt{C} \textit{carry flaget} is kivonja a kisebbítendõbõl.

\subsubsection{Inkrementálás, dekrementálás}
Az inkrementálást (\mintinline{asm}{INC}) és a dekrementálást (\mintinline{asm}{DEC}) megvalósító mûveletek gyakorlatilag rendre megegyeznek az összeadás, illetve kivonás mûveletekkel, annyi különbséggel, hogy a második operandust mindkét esetben 1-nek tekintjük.  

\subsection{Logikai utasítások - \texttt{AND, XOR, OR, CP}}
Az \textit{és} (\mintinline{asm}{AND}), \textit{kizáró vagy} (\mintinline{asm}{XOR}), \textit{vagy} (\mintinline{asm}{OR}), és összehasonlító (\mintinline{asm}{CP}, \textit{compare}) mûveletek is legalább olyan alapvetõek, és fontosak mint az elõzõekben tárgyalt aritmetikai mûveletek. Közülük az elsõ hármat nagyon egyszerû megvalósítani, hiszen a legtöbb programozási nyelv képes ezen mûveletek elvégzésének reprezentálására az \& (\textit{és}), \^{} (\textit{kizáró vagy}), és a | (\textit{vagy}) operátorok segítségével. \\
Az fent említett elsõ három mûvelet implementálása tehát könnyû feladat, a \textit{flagek} be\-ál\-lí\-tá\-sa pedig szintén egyszerû. A \mintinline{asm}{XOR} és \mintinline{asm}{OR} \textit{flag} kezelése megegyezik: ha a végeredmény 0, akkor a \texttt{Z} flag legyen 1 (egyébként 0), az összes többi \textit{flaget} pedig állítsuk 0-ra. Az \mintinline{asm}{AND} esetén is hasonló a helyzet, annyi különbséggel, hogy a \texttt{H} flaget minden esetben 1-ra kell állítani. \\
A \mintinline{asm}{CP} mûvelet kicsit különbözik a többitõl -- maga a mûvelet összehasonlít két értéket, és ha az értékük megegyezik, a \texttt{Z} \textit{flaget} 1-re állítja. Ennek mûködése tulajdonképpen megegyezik a kivonás mûveletével, csak a különbséget nem tároljuk sehol, a \textit{flagek} be\-ál\-lí\-tá\-sa a fontos -- ebben a tekintetben teljesen ekvivalens az összehasonlítás a kivonással.

\subsection{Verem utasítások - \texttt{PUSH, POP}}
Lehetõség van regiszterpárok eltárolására a veremben -- ezt a funkciót a \mintinline{asm}{PUSH} és a \mintinline{asm}{POP} utasítások valósítják meg. A \mintinline{asm}{PUSH} az \texttt{AF, BC, DE, HL} (konkrét mûveletben szereplõ) regiszterpárokat teszi bele a verembe (az \texttt{SP} által mutatott memóriacímre), a második regiszter taggal kezdve. A \mintinline{asm}{POP} mûvelet pedig fordított sorrendben veszi ki az értékeket a verembõl, majd állítja be velük a megfelelõ regiszterek értékeit.

\subsection{Eljárás utasítások - \texttt{JP, CALL, RET}}
Ahhoz, hogy a programozók eljárásokat tudjanak írni a programok fejlesztése során, különféle utasításokra van szükségük. Ezek az utasítások a Game Boy architektúrájában az ugrás (\mintinline{asm}{JP}), az eljáráshívás (\mintinline{asm}{CALL}) és a visszatérés (\mintinline{asm}{RET}). \\
A \mintinline{asm}{JP} utasítás mûködése nagyon egyszerû: a CPU \texttt{PC} regiszterét állítja a paraméterben megadott memóriacímre, így a processzor ott fogja folytatni a futását. Több típusú \mintinline{asm}{JP} mûvelet is szerepel a CPU utasításai között:
\begin{itemize}
  \item \mintinline{asm}{JP (HL)}: a \texttt{HL} regiszterpárban tárolt címre ugrik,
  \item \mintinline{asm}{JP 0x4a2a}: a paraméterben megadott 16 bites címre ugrik,
  \item \mintinline{asm}{JP NZ 0x4a2a}: akkor ugrik a paraméterben megadott 16 bites címre, ha a \texttt{Z} \textit{flag} értéke 0, 
  \item \mintinline{asm}{JP NC 0x4a2a}: akkor ugrik a paraméterben megadott 16 bites címre, ha a \texttt{C} \textit{flag} értéke 0, 
  \item \mintinline{asm}{JP Z 0x4a2a}: akkor ugrik a paraméterben megadott 16 bites címre, ha a \texttt{Z} \textit{flag} értéke 1,
  \item \mintinline{asm}{JP C 0x4a2a}: akkor ugrik a paraméterben megadott 16 bites címre, ha a \texttt{C} \textit{flag} értéke 1. 
\end{itemize}

\noindent A \mintinline{asm}{CALL} mûvelet annyiban hasonlít az elõzõ \mintinline{asm}{JP} mûvelethez, hogy szintén a paraméterben megadott címre fog ugrani a \texttt{PC} regiszter átállításával, elõtte azonban az aktuális \texttt{PC} értékét beleteszi a verembe, elmentve azt. A \mintinline{asm}{JP} mûvelethez hasonlóan szintén vannak feltételes eljárás hívás utasítások, melyek a \texttt{Z} és a \texttt{C} \textit{flagek} aktuális állapota szerint mû\-köd\-nek. \\
A \mintinline{asm}{RET} utasítás az elõzõ (\mintinline{asm}{CALL}) utasítással kéz a kézben jár: kiveszi a verembõl a két legfelsõ értéket -- amelyek együtt egy memóriacímet alkotnak --, majd a \texttt{PC} regisztert erre az értékre állítja be, így tulajdonképpen az eljárás hívás végeztével a CPU visszatér arra a címre, ahol az eljárás hívása elõtt tartott. Szintén vannak a \texttt{Z} és \texttt{C} \textit{flagekhez} kötött \mintinline{asm}{RET} utasítások, illetve létezik még egy \mintinline{asm}{RETI} opkódú utasítás is, amely a visszatérés után engedélyezi az \textit{Interrupt Enable} regiszterben az összes \textit{interruptot}.

\subsection{Bitmanipulációs utasítások - \texttt{BIT, RES, SET, SWAP}}
Rendelkezésre állnak bitmanipulációs utasítások, amelyekkel regiszterek, vagy a me\-mó\-ri\-á\-ban lévõ bájtok bitjeivel végezhetünk mûveleteket: változtathatjuk (\mintinline{asm}{RES}, \mintinline{asm}{SET}, \mintinline{asm}{SWAP}), vagy lekérhetjük (\mintinline{asm}{BIT}) õket. Ezek természetesen fontos mûveletek, így a többi CPU utasításhoz hasonlóan törekedni kell a pontos emulációjukra. \\
A \mintinline{asm}{RES} és \mintinline{asm}{SET} esetében rendre 0 (\textit{reset}) vagy 1 (\textit{set}) értéket adhatunk az utasítás pa\-ra\-mé\-te\-re\-i\-ben\footnote{Paraméter alatt jelen esetben nem külön beolvasott bájtokat tekintünk, hanem a konkrét mûvelethez (a processzor architektúrájának részeként) specifikált paramétereket.} megadott bitnek. Az \textit{elsõ pa\-ra\-mé\-ter} a módosítandó bit indexe az adott bájtban, a \textit{második paraméter} pedig maga a mondosítandó bitet tartalmazó regiszter vagy \texttt{(HL)} regiszterpárral megadott memóriacím. Ezek az utasítások nincsenek hatással az \texttt{F} \textit{flag} regiszterre. Az implementációt tekintve egy egyszerû bitmaszkolással, majd \textit{vagy}, ill. \textit{és} mûveletekkel lehet elérni egy-egy bit módosítását egy \mintinline{rust}{u8} változó esetén.\\
A \mintinline{asm}{BIT} mûvelettel lehet lekérni egy konkrét bit értékét -- az utasítás az eredményét a \texttt{Z} \textit{flag} segítségével tudjuk kiolvasni: amennyiben az eredmény 0 volt, a \texttt{Z} 1-gyel lesz egyenlõ, egyébként pedig 0-val. Ami a további \textit{flageket} illeti, az \texttt{N} \textit{flaget} mindig \textit{reseteli}, a \texttt{H}-t pedig mindig beállítja az utasítás. Implementációban bitmaszkolással tudjuk megkapni egy adott bit értékét. \\
A \mintinline{asm}{SWAP} utasítás esetében egy paraméter adott: a módosítani kívánt regiszter. Maga a mûvelet nagyon egyszerû: fel kell cserélni a regiszterrel vagy memóriacímmel megadott bájt felsõ és alsó 4 bitjét egymással, így tehát például a $\texttt{11110000}_2$ bájtból a \mintinline{asm}{SWAP} elvégzése után $\texttt{00001111}_2$ lesz. Ha a végeredmény nullával egyenlõ, akkor az utasítás beállítja a \texttt{Z} \textit{flaget} 1-re, egyébként pedig nullára. A maradék három \textit{flag} minden esetben \textit{resetelésre} kerül.

\subsection{\textit{Rotate} és \textit{Shift} - \texttt{RLC, RRC, RL, RR, SLA, SRA, SRL}}
\subsubsection{\textit{Rotate} mûveletek} 
A Game Boy processzorának architektúrájában több bitforgató utasítás is van: \mintinline{asm}{RLC}, \mintinline{asm}{RRC}, \mintinline{asm}{RLCA}, \mintinline{asm}{RRCA}, \mintinline{asm}{RL}, \mintinline{asm}{RR}, \mintinline{asm}{RLA}, és \mintinline{asm}{RRA}. Ezek többé-kevésbé ugyan olyan módon mûködnek. Vegyük példának a legegyszerûbb, balra forgató utasítást, az \mintinline{asm}{RLC}-t. Egy $\texttt{11110000}_2$ bájt esetén a balra forgatás eredménye a következõ lesz: $\texttt{11100001}_2$. Ez az érték úgy született, hogy minden bitet eggyel balra tolunk, a 7. bit pedig \textit{körbefordul} -- belõle lesz a 0. bit. A forgató mûveleteket ez a körbefordulás különbözteti meg az eltoló mûveletektõl, ott ilyenrõl nincs szó.

\subsubsection{\textit{Shift} mûveletek}

\subsection{Egyéb, speciális utasítások}
NOP, STOP, DAA, SCF, CPL, CCF, HALT, RST, EI, DI

\newpage
\section{RAM}
\section{Idõzítõk}
