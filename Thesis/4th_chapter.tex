\chapter{A kijelzõ és a PPU implementációja}
A processzor és memória modulok után következik a Game Boy emulátor legnehezebb moduljának, a PPU-nak a fejlesztése. Ennek bonyolultsága abban rejlik, hogy rendkívül sok attribútummal, és egyéb jellemzõkkel, mini-mechanizmusokkal rendelkezik, amelyek között meg kell teremteni az együttmûködést és kohéziót. Ezeket természetesen egyenként, pontosan kell megvalósítani annak érdekében, hogy az emuláció és ezzel együtt a meg\-je\-le\-ní\-tés is pontos legyen. Természetesen ez elvárható, hiszen ez azon kevés modulok közé tartozik, amelyek közvetlenül tartják a kapcsolatot a felhasználóval, így minden apró eltérés szembeötlõ lehet. \\
A \textit{Pixel Feldolgozó Egység (Pixel Processing Unit)} implementációja elõtt azonban annak "keretrendszerét" kell megvalósítani, az LCD kijelzõ mûködését, állapotainak rep\-re\-zen\-tá\-ci\-ó\-ját. Ezek nélkül a PPU nem tudna mûködni, hiszen a kijelzõ státusz állapotainak megfelelõen történik a kirajzolás.

\section{Az LCD kijelzõ}

\begin{wrapfigure}{l!}{\textwidth/2}
    \centering
    \includegraphics[width=\textwidth/2]{./Resources/Blank.eps}
    \caption{\textit{A letapogató és az üresjáratok}}
    \label{fig:blank}
\end{wrapfigure}

A Game Boy kijelzõjérõl a hardver specifikáció ismertetése során már volt szó -- ahogy ott is megemlítésre került, a szóban forgó LCD kijelzõ 166 $\times$ 144 pixel felbontású, 4 árnyalat megjelenítésére képes. A képernyõre renderelt képpontokat a \texttt{minifb} könyvtárral fogjuk megjeleníteni, amelynek struktúráit, és alapvetõ funkcióit az 1.2.2.-es rész taglalja. Ahhoz azonban, hogy a renderelést megfelelõ módon eltudjuk végezni, oda kell figyelni az LCD kijelzõ állapotaira, megszakításokra, egyéb jellemzõkre. \\
A konzol hardverének tervezése során a mérnökök több képernyõfrissítési módszert és megoldást a -- már akkor korosnak számító -- CRT technológiából vettek kölcsön. Mint az ismeretes, a katódsugárcsöves megjelenítõk esetében a képernyõt sorról sorra pásztázta végig egy elektronnyaláb, majd az utolsó sor végeztével a mûveletet újból a legelsõ sorral folytatta. Azonban -- ahogy a \ref{fig:blank}-es ábrán is megfigyelhetõ -- a CRT-nek több idõre van szüksége ahhoz, hogy kirajzolja a megfelelõ képpontokat a megfelelõ helyre, nem csak végigszalad rajtuk. Idõ kell tehát ahhoz, hogy az egyes sorok végérõl a sugárnyaláb átvándoroljon a következõ sor elejére, ahogy az is idõbe kerül, hogy a nyaláb a képernyõ utolsó pixelérõl (jobb alsó sarok) visszamenjen a legelsõhöz (bal felsõ sarok). Természetesen ez utóbbi sokkal tovább fog tartani mint az elõbbi -- ezeket egyébként \textit{horizontális üresjáratnak} (vagy \textit{HBlank}-nak) illetve \textit{vertikális üresjáratnak} (vagy \textit{VBlank}-nak) nevezzük. \\
Ezek az üresjáratok nagyban meghatározzák a PPU emulációjának ritmusát, több dolgot is szûk intervallumon belül kell elvégezni. Az LCD kijelzõ által meghatározott intervallumokat, illetve pontos szinkronizációs idõpontokat az alábbi táblázat tartalmazza.

\begin{table}[h!]
  \centering
  \begin{tabular}{|>{\columncolor{GameBoyBlue}}l|c|c|} 
   \hline
  Esemény & \cellcolor{GameBoyBlue} PPU mód azonosító & \cellcolor{GameBoyBlue} Igénybevett idõ \\ \hline
  \textit{Scanline} (OAM elérése) & 2 & 80 órajelciklus \\ \hline
  \textit{Scanline} (VRAM elérése) & 3 & 172 órajelciklus \\ \hline
  Horizontális üresjárat & 0 & 204 órajelciklus \\ \hline
  Egy sor kirajzolása &  & \textbf{456 órajelciklus} \\ \hline
  Vertikális üresjárat & 1 & 4560 órajelciklus \\ \hline
  Képkocka (letapogatások és üresjáratok) &  & 70224 órajelciklus \\ \hline
  \end{tabular}
  \caption{\textit{A PPU idõzítése}}
  \label{table:1}
\end{table}

\noindent Ez alapján tehát rekonstruálni tudjuk az LCD kijelzõ és a PPU idõzítéseinek mûködését, és azt, hogy egymással és a processzorral hogyan tudjuk szinkronban tartani õket. Ehhez szükség lesz egy, a CPU fõ ciklusában minden alkalommal meghívott valamilyen ak\-tu\-a\-li\-zá\-ló függvényre, ahol ellenõrzés alatt lehet tartani a CPU és PPU együttmûködését, szin\-kro\-ni\-zá\-ci\-ó\-ját. Ez a függvény az \texttt{update\_n\_sync} lesz, melynek tartalma a következõ:

\begin{minted}{rust}
  self.lcd_status_update(cpu);
  self.scanline_count += cycle as u16;

  if self.scanline_count >= 456 {
      self.scanline_count = 0;

      if cpu.RAM[0xFF44] < 144 { 
      self.draw_line(cpu); 
      }

      if cpu.RAM[0xFF44] == 144 { 
      self.interrupt.IRQ(cpu, 0); 
      }

      cpu.RAM[0xFF44] += 1;

      if cpu.RAM[0xFF44] > 153 { 
      cpu.RAM[0xFF44] = 0; 
      }
  }
\end{minted}

\noindent A fenti programrészlet tehát menedzseli a renderelést: a megfelelõ idõben meghívja a megfelelõ függvényeket, miközben frissíti a megfelelõ változókat. Kicsit bõvebben ez annyit tesz, hogy elõször is meghívja az \texttt{lcd\_status\_update} függvényt (késõbb bemutatásra kerül), majd hozzáadja az utolsó CPU operáció mûveletidejét egy szám\-lá\-ló\-hoz (\texttt{scanline\_count}), amellyel számon tudjuk tartani, hogy mennyi mûvelet elvégzése szükséges a következõ pixelsor kirendereléséig. Ha ez a számláló nagyobb egyenlõ, mint 456, akkor további ellenõrzéseket végzünk. \\
Elõször is lenullázzuk a számláló változót, majd megnézzük, hogy a \texttt{0xFF44} me\-mó\-ri\-a\-cí\-men található érték elérte-e a 144-es értéket. Ha nem, akkor rajzoljuk ki a sort. Az elõbb említett \texttt{0xFF44}-es címen található érték azt mutatja, hogy a PPU éppen melyik sornál jár a kirajzolásban, ezért hasonlítjuk össze 144-gyel: pontosan ennyi sora van a kijelzõnek. \\
Ha a \texttt{0xFF44}-es érték megegyezik 144-gyel, tehát az utolsó sor is ki lett rajzolva a képernyõre, 0-s azonosítójú megszakítási kérést kell küldeni a processzornak, ez lé\-nye\-gé\-ben a \textit{VBlank} mûvelet elvégzését takarja. Ezeket az elágazásokat követõen növelni kell a \texttt{0xFF44}-en található értéket (\textit{scanline}, letapogató) eggyel, hiszen a következõ sorra lépünk. \\
A következõ, végsõ \texttt{if} elágazás igen érdekes: a \textit{scanline} értékét vizsgálja, azt nézi meg, hogy nagyobb-e mint 153. \textit{De miért pont 153?} Egész pontosan azért, mert a \ref{table:1}-es táb\-lá\-zat\-ban ismertetettek szerint a \textit{VBlank} mûvelet végrehatjási ideje pontosan 10-szerese az egy sor kirajzolásáénak. A képernyõn lévõ sorok számát 0-tól indexeljük, így lesz a 144-bõl 143, amihez ha hozzáadunk 10-et, amíg a \textit{VBlank} tart, megkapjuk a 153-as számot. Amint elértük a 153. sort (vagyis befejezõdött a \textit{VBlank} mûvelet), kezdhetjük a következõ képkocka renderelését a 0. sortól. 

\subsection{Az LCD státuszok}
A következõkben a fent említett \texttt{lcd\_status\_update} által elvégzett feladatokat, azaz az LCD kijelzõ státuszait és az azokra való reagálást fogom bemutatni. \\
Az kijelzõ aktuális állapotát a \texttt{0xFF41} memóriacímen található LCD Státusz Regiszter tárolja a 0. és 1. biteken -- ebbõl következik hogy 4 ($2^2$) ilyen állapot létezik:

\begin{itemize}
  \item \texttt{00}: \textit{HBlank}
  \item \texttt{01}: \textit{VBlank}
  \item \texttt{10}: \textit{Sprite} adatok keresése a memóriában (OAM)
  \item \texttt{11}: Adatok másolása a PPU számára a VRAM-ba
\end{itemize}

\noindent Mihelyst a \textit{scanline} újra kezdi a képkocka kirajzolását az elsõ sortól, a következõ mû\-ve\-le\-tek ciklusát hajtja végre újra és újra: elõször is \texttt{10}-ra állítódik az állapot, majd \texttt{11}-re, végül pedig \texttt{00}-ra. Amikor elér a \textit{VBlank} mûvelethez, a státusz \texttt{01} lesz egészen az üresjárat végéig. Ezt követõen ismét az \texttt{10} állapotot veszi fel, és folytatódik a ciklus a fentiek szerint. Az egyes állapotokhoz tartozó végrehajtási idõket tartalmazza a \ref{table:1}-es táblázat. 

\subsection{Az LCD interruptjai és flagje}
Abban a pillanatban, amikor az LCD kijelzõ állapota megváltozik, és a \texttt{00}, \texttt{01} vagy \texttt{10} módba kerül (a fent ismertetetteknek megfelelõen), interrupt hívás következhet be. Az LCD Státusz Regiszter 3., 4. és 5. bitjei felelnek az elõbb említett 3 mód megszakításainak engedélyezéséért vagy letiltásáért (a \texttt{0xFFFF}-en található \textit{Interrupt Enable} regiszterhez hasonlóan), viszont ezeket nem az emulátor, hanem a játék fejlesztõi állíthatták be az igényeknek megfelelõen. A megszakítások LCD módokra való megfeleltetése a következõk szerint alakul:

\begin{itemize}
  \item 3. bit: \texttt{00}-s LCD mód megszakításának engedélyezése, tiltása,
  \item 4. bit: \texttt{01}-s LCD mód megszakításának engedélyezése, tiltása,
  \item 5. bit: \texttt{10}-s LCD mód megszakításának engedélyezése, tiltása.
\end{itemize}

\noindent Fontos megjegyezni, hogy az LCD módok közül feltétlenük implementálni kell a kijelzõ kikapcsolásakor a \texttt{01}-es módra való váltást, mert ha ezt nem tesszük meg, több játék is meg fog akadni a megszakítás elvégzésének hiánya miatt. \\

\noindent Ötletes megoldást tesz lehetõvé az LCD Státusz Regiszter 2. és 6. bitje. A második bitet \textit{Coincidence Flag}nek nevezzük, és akkor állítjuk 1-re, ha a \textit{scanline} aktuális sor értéke (\texttt{0xFF44}) megegyezik az \texttt{0xFF45}-ös memóriacímen található értékkel. A hatodik bit azt szabályozza, hogy ha a \textit{Coincidence Flag} be van állítva, akkor legyen-e megszakítás kérés. Ennek a megoldásnak a segítségével tudtak a játékfejlesztõk különféle speciális effekteket leprogramozni, hiszen a \textit{Coincidence Flag} segítségével lehetett vizsgálni és interruptot kérni egy konkrét sor esetén.

\section{PPU - Pixel Feldolgozó Egység}
Az elõzõ alfejezetben ismertetésre került a Game Boy kijelzõjének viselkedése, az ehhez felhasznált eszközök, módszerek, és a keretrendszer ami emögött mûködik. Az idõzítés, megszakítások, módok és egyebek azonban önmagukban nem elegek ahhoz hogy az e\-mu\-lá\-tor kirenderelhesse a képet a \textit{framebuffer} ablakba, ehhez további vizsgálatok, és implementáció szükséges. A sorrend a következõ: elõször is a megjelenítéshez szükséges alapvetõ ismeretekrõl lesz szó, majd a \textit{tile}-ok, vagy csempék renderelésén keresztül fogom bemutatni azokat a módszereket amikre figyelni kell. A \textit{sprite} renderelést tartalmazó rész a \textit{tile} rendereléshez viszonyított különbségeket fogja tartalmazni.

\subsection{Alapvetõ tudnivalók}
A Game Boy a grafikák megjelenítéséhez \textit{tile}-okat és \textit{sprite}-okat használ, ezek segítségével állítja össze a kívánt mintát a rendereléshez. Itt mindjárt két definícióval is találkozunk, ezek a következõket jelentik: a \textit{tile}-ok a játék hátterét alkotó, leginkább ismétlõdõ mintákat ábrázoló csempék, amelyek statikusak, a játéknak a kontextust adják meg, míg a \textit{sprite}-ok a mozgó, folyton helyet változtató, villogó részek a képernyõn, illetve az irányítható karakterek. Mindkettejükrõl elmondható, hogy általában 8$\times$8 pixel méretûek, viszont elõfordulhatnak nagyobb, 8$\times$16 pixelesek is, melyek többnyire a játszható karaktereket ábrázolták (pl. Mario). \\

\begin{figure}[h!]
    \centering
    \includegraphics[width=10cm]{./Resources/screenmap.eps}
    \caption{\textit{A képernyõ scrollozásos megoldása -- az SCX az X koordinátát, az SCY pedig az Y koordinátát tartalmazó regiszter}}
    \label{fig:screenmap}
\end{figure}

\noindent Az már többször is említésre került, hogy a hardver kijelzõjének felbontása 160$\times$144 pixel méretû, viszont \textit{virtuális} tekintetben 256$\times$256 pixel a rajzolható terület mérete, amely ekvivalens 32$\times$32 darab 8$\times$8 méretû csempével. Ebbõl a nagyobb, 1:1 arányú méretbõl aztán úgy lesz a már sokat emlegetett 160$\times$144, hogy egy pontosan ekkora méretû részt mozgatunk a 256$\times$256 méretû területen. A mozgatott "ablak" koordinátái külön el vannak tárolva egy regiszterben, ezt a jétékfejlesztõk szabadon használhatták. A fenti, \ref{fig:screenmap}-es ábra mutatja a fent ismertetett \textit{scroll} mechanizmust. \\
Fontos még megemlíteni, hogy létezik egy harmadik típusú ábrázolási mód, ez pedig a \textit{window} (ablak). Ennek segítségével a megjelenített pixelek a háttér \textit{tile}-ok elõtt, viszont a \textit{sprite}-ok mögött foglalnak helyet. A programozók ezt a megjelenítési módot használhatták az alkalmazásaik felhasználói felületeinek HUD\footnote{\textit{Heads-Up Display}: más néven \textit{status bar}, általában a játékos állapotának, illetve a játékban elért pontszámának közlésére szolgáló felület, az UI szerves része.}-jaként, melyekre tetszõleges ábrákat, szöveget helyezhettek el.

\subsection{Az LCD Control Register}
Az elõzõ alfejezetben említett LCD Státusz Regiszterhez hasonló, szintén az LCD kijelzõ állapotait és a megjelenítést segítõ regiszter az \textit{LCD Control Register}, amelynek me\-mó\-ri\-a\-cí\-me a \texttt{0xFF40} és amely inkább a rendereléshez áll közelebb: számos, a PPU által aktívan használt paramétert tartalmaz. Ezek rendre a következõk:

\begin{itemize}
  \item \textbf{7. bit:} Ezzel a bittel lehet állítani, hogy az LCD kijelzõ ki-, vagy be legyen-e kapcsolva. Amennyiben nincs bekapcsolva (értéke 0), nem rajzolunk semmit sem. Ezt az elõzõ, LCD kijelzõ funkcióit implementáló kódrész kezeli le.

  \item \textbf{6. bit:} Ez a bit azt mondja meg, hogy a játék a memória mely részében keresse a \textit{window} kirajzolásához szükséges \textit{tile}-ok bájtjait. Ezek a bájtok az adott csempék azonosítóit tárolják, minden csempéhez pontosan egy azonosító tartozik. A\-meny\-nyi\-ben az értéke 0, úgy az intervallum \texttt{0x9800 - 0x9BFF}, egyébként pedig \texttt{0x9C00 - 0x9FFF}.

  \item \textbf{5. bit:} Ez a bit szolgál a megjelenített \textit{frame}-en belüli \textit{window}-k ki-, illetve be\-kap\-cso\-lá\-sá\-ra. 0 érték esetén nem rajzoljuk ki ezeket, egyébként igen.

  \item \textbf{4. bit:} Ezzel a bittel lehet állítani, hogy a háttérként, illetve \textit{window}-ként kirajzolt \textit{tile}-ok bájtjai merre találhatóak. Ezek a bájtok a konkrét csempéket tárolják. 0 érték esetén a \textit{tile}-ok helye a memóriában \texttt{0x8800 - 0x97FF}, 1-es érték esetén pedig \texttt{0x9C00 - 0x9FFF}. Érdekesség, hogy amennyiben az 0-s érték által reprezentált módban vagyunk, úgy a 6-os bitnél említett azonosító bájtok elõjeles bájtok, ér\-ték\-kész\-le\-tük pedig ennek megfelelõen a $[ -128, 128 ]$-as intervallum.

  \item \textbf{3. bit:} Ez a bit azt mondja meg, hogy a játék a memória mely részében keresse a háttér kirajzolásához szükséges \textit{tile}-ok bájtjait. Ezek a bájtok is az adott csempék azonosítóit tárolják, a 6-os bithez hasonló módon. Ha az értéke 0, akkor az in\-ter\-val\-lum \texttt{0x9800 - 0x9BFF}, egyébként pedig \texttt{0x9C00 - 0x9FFF}.

  \item \textbf{2. bit:} Ezzel a bittel azt lehet megadni, hogy a kirajzolandó \textit{sprite}-ok mérete a már említettek szerint 8$\times$8-as legyen (0 értékû bit esetén), vagy pedig 8$\times$16-os (1-es értékû bit esetén).

  \item \textbf{1. bit:} Ez a bit az 5-ös bithez hasonló módon azt tudja szabályozni, hogy kirajzoljuk-e a vonatkozó adatokat. A konkrét adatok itt természetesen nem a \textit{window}-hoz fognak tartozni, hanem a \textit{sprite}-okhoz: 0-s érték esetén ezek renderelését lehet letiltani, illetve 1-es érték esetén engedélyezni.

  \item \textbf{0. bit:} Ez a bit elõzõhöz, és az 5-ös bithez hasonlóan a kirajzolandó adatokat korlátozza: ebben az esetben a hátteret alkotó \textit{tile}-ok renderelését lehet letiltani 0-s értékkel, vagy engedélyezni 1-essel.
\end{itemize}

\noindent Most, hogy ismerjük a fenti, LCD Control Register által tárolt beállításokat, és el lehet kezdeni implementálni a hátteret alkotó \textit{tile}-ok kirajzolását végzõ eljárás(oka)t. Elõtte azonban készíthetünk egy, az adott sort renderelõ, egyszerû függvényt:

\begin{minted}{rust}
    fn draw_line(&mut self, cpu : &mut CPU) {

        // Check if the tile rendering 
        // is whether on or off
        if CPU::get_bit(0, cpu.RAM[0xFF40])  {
            self.draw_tile(cpu);
        }

        // Check if the sprite rendering
        //  is whether on or off
        if CPU::get_bit(1, cpu.RAM[0xFF40])  {
            self.draw_sprite(cpu);
        }
    }
\end{minted}