\chapter{Joypad}

A PPU, azaz a Game Boy renderelésért felelõs grafikus alrendszere után itt az ideje a másik bemeneti modul, a \textit{joypad} implementálásának. Ahogy a PPU esetében is, úgy itt is elmondható, hogy nagyon fontos részegységrõl van szó, hiszen míg a renderelés eredményét ``csak'' \textit{látja} a kijelzõn a felhasználó, addig a \textit{joypad} gombjait megnyomva tud érdemben \textit{kommunikálni}, reagálni egyes helyzetekre, interakcióba lépni a hardverrel, vagy az emulátorral, amely ennek hatására változtatja a mûködését. Ha rossz a gombnyomás élménye, többedszerre sem érzékeli a hardver vagy emulátor a gombnyomást, esetleg késik a reakció a gombnyomásra, az mind-mind csalódottságot és idegességet ébreszt a felhasználóban, mely következtében végsõ soron abbahagyja a játékot. Nagyon fontos tehát nemcsak az eredeti hardver viselkedésének emulálása, hanem az is, hogy az emulálás élménye se maradjon el a Game Boy-étól.

\section{Technikai háttér és a \textit{Joypad Register}}

\begin{figure}[h!]%
    \centering
    \subfloat[]{\includegraphics[height=4.2cm]{./Resources/v2/eps/joypad.eps}}%
    \quad
    \subfloat[]{\includegraphics[height=4.5cm]{./Resources/joypad_sch.eps}}%
    \caption{\textit{A joypad gombjai (a) és sematikus kapcsolási (logikai) rajza (b)} \cite{ninpat}}%
    \label{fig:joypad}%
\end{figure}

\noindent Ahogy a \ref{fig:joypad}-es ábrán látható, a Game Boy konzolon 8 darab gomb található. Ezeket szokás két nagyobb csoportra is bontani. Az egyik csoport a bal oldalon látható ún. \textit{D-pad}, amely látszólag egy nagy, plusz jel alakú gomb, az igazság azonban az, hogy 4 gombot olvaszt eggyé. A plusz jel négy ágának végein találhatóak meg az egyes irányokhoz rendelt gombok -- innen jön a \textit{D-pad} megnevezés is: \textit{Direction pad}, azaz \textit{irányító gomb}. Ennek segítségével tudjuk a bal kéz hüvelykujjával irányítani a játékonként változó elemet -- legyen az játszható karakter, Tetris-elem, stb.
\\ A másik csoportot a maradék gombok, az akciógombok alkotják: \textit{A}, \textit{B}, \textit{Select} és \textit{Start}. Az elsõ kettõvel általában a játékon belüli akciókat, képességeket, funkciókat tudjuk aktiválni, míg az utóbbi kettõ a játék megszakítását, illetve a menükben való navigálást segíti.
\\ Ami a fenti, \ref{fig:joypad}-es ábra \textit{(b)} részét illeti: ez a kép mutatja be a Game Boy gombjainak kapcsolási rajzát. A karikák mutatják az egyes gombokat, mellettük a nevükkel, a vonalak pedig az õket összekötõ vezetékeket jelölik. Elsõ pillantásra bonyolultnak tûnhet, és fel\-me\-rül\-het bennünk, hogy miért nem két vonal (azaz vezeték) csatlakozik minden gombhoz -- ezekre egyfajta kapcsolóként gondolva, amelyek nyomásra zárják az áramkört. Nos, a Nintendo japán mérnökei ott spóroltak és optimalizáltak, ahol tudtak -- ezt a gombok összekötésének megtervezésekor is szem elõtt tartották. A hétköznapi számítógép bil\-len\-tyû\-ze\-tek\-hez hasonló módon, egyfajta mátrixos elrendezést találtak ki, ezzel sok kábelt megspórolva. Ennek megfelelõen van tehát két kábelcsoport, az egyik a \textit{P10}, \textit{P11}, \textit{P12}, \textit{P13}, amelyek rendre egy-egy gombhoz vannak kötve mindkét gombcsoportban, a másik pedig a \textit{P14} és \textit{P15}, amelyek azt jelölik ki, hogy melyik gombcsoportról van éppen szó. Ennek mintájára mûködik az \texttt{0xFF00} memóriacímen található \textit{Joypad Register}, amely a mérnökök op\-ti\-ma\-li\-zá\-ci\-ó\-já\-nak hála egy bájtban képes eltárolni az összes gomb aktuális állapotát. Ennek a bájtnak a bitjei a következõket jelentik \cite{ninprog}:

\begin{itemize}
  \item \textbf{6--7. bitek:} nincsenek használatban.
  \item \textbf{5. bit:} akciógomb kiválasztó bit, a \textit{P15}-ös vezetéknek felel meg. 0 érték esetén kerül kiválasztásra az \textit{A}, \textit{B}, \textit{Select} és \textit{Start} gombok csoportja.
  \item \textbf{4. bit:} iránygomb kiválasztó bit, a \textit{P14}-es vezetéknek felel meg. 0 érték esetén kerül kiválasztásra a \textit{D-pad} 4 darab iránygombja.
  \item \textbf{3. bit:} a 4. és 5. bitek értékétõl függõen a lefelé mutató iránygomb vagy a \textit{Start} gomb állapotát mutatja. Akkor tekintjük lenyomott állapotúnak, ha az értéke 0. A \textit{P13}-as vezetéknek felel meg.
  \item \textbf{2. bit:} a 4. és 5. bitek értékétõl függõen a felfelé mutató iránygomb vagy a \textit{Select} gomb állapotát mutatja. Akkor tekintjük lenyomott állapotúnak, ha az értéke 0. A \textit{P12}-es vezetéknek felel meg.
  \item \textbf{1. bit:} a 4. és 5. bitek értékétõl függõen a balra mutató iránygomb vagy a \textit{B} gomb állapotát mutatja. Akkor tekintjük lenyomott állapotúnak, ha az értéke 0. A \textit{P11}-es vezetéknek felel meg.
  \item \textbf{0. bit:} a 4. és 5. bitek értékétõl függõen a jobbra mutató iránygomb vagy az \textit{A} gomb állapotát mutatja. Akkor tekintjük lenyomott állapotúnak, ha az értéke 0. A \textit{P10}-es vezetéknek felel meg.
\end{itemize}

\noindent Érdekesség, hogy a fenti regiszter esetén minden esetben az jelenti a lenyomott állapotot, ha az adott bit értéke 0. Ebbõl az következik, hogy a megvalósítás során a regiszter esetében a \texttt{0xFF} érték lesz a \textit{default}, ezt kell frissíteni, és a megfelelõ biteket 0-ra állítani a megfelelõ mûködés eléréséhez. A következõ alfejezet fogja bemutatni, hogy mindezt hogyan lehet implementálni.

\section{Implementáció}

\begin{wrapfigure}{l!}[-1cm]{0.3\textwidth}
\begin{minted}[linenos]{asm}
  LD A,$20
  LD ($FF00),A 
  LD A,($FF00)
  LD A,($FF00) 
  CPL
  AND $0F
  SWAP A
  LD B,A
  LD A,$10
  LD ($FF00),A
  LD A,($FF00)
  LD A,($FF00)
  LD A,($FF00)
  LD A,($FF00)
  LD A,($FF00)
  LD A,($FF00)
  CPL
  AND $0F
  OR B
  LD B,A
  LD A,($FF8B)
  XOR B
  AND B
  LD ($FF8C),A
  LD A,B
  LD ($FF8B),A
  LD A,$30
  LD ($FF00),A
  RET
\end{minted}
\caption{\textit{
\\ A Ms. Pacman játék 
\\ gombnyomáskezelõ 
\\ kódja} \cite{pandoc}}
\label{fig:pacman}
\end{wrapfigure}

\noindent Az \ref{fig:pacman}-es ábrán látható kód mutatja a Ms. Pacman játék kódjának egy részletét, amely a gombok lenyomását figyeli. Elõször betölti az \texttt{A} regiszterbe a \texttt{0x20} (0b00100000) értéket (1. sor), amellyel kijelöli a \textit{P14}-es csatlakozást, majd az \texttt{A}-t a \textit{Joypad Registerbe} tölti (2. sor). A \textit{Joypad Register} \texttt{A} regiszterbe történõ kétszeri betöltéssel egyfajta várakozást valósít meg (3--4. sor). Ezt követõen veszi az \texttt{A} regiszter komplementerét (5. sor), majd kinullázza az alsó 4 bitjét, felcseréli azt a felsõ 4 bittel, és elmenti a \texttt{B} regiszterbe (6--8. sor). A 9. sorban kijelöli a \textit{P15}-ös vezetéket, majd a 10.-ben eltárolja azt a \textit{Joypad Registerbe}. Ez után a 11.-tõl a 16. sorig várakozik, majd komplementálja \texttt{A}-t, veszi az alsó 4 bitjét, összevagyolja \texttt{B}-vel, és elmenti a \texttt{B}-be (17--20. sor). A következõ részben beolvassa a régi \textit{joypad} állapotot a memóriából, beállítja a jelenleg lenyomva tartott gombokat, elmenti az új állapotot reprezentáló bájtot, kiveszi a \textit{P14} és \textit{P15} kijelölését, \textit{reseteli} az állapot regisztert, majd visszatér a szubrutin (21--29. sor). \\
A fenti magyarázat azért volt fontos, mert rávilágít egy olyan viselkedésre, amely felett nagy valószínûséggel elsiklik a legtöbb emulátorfejlesztõ: ahhoz, hogy a lenyomott gomb kódját a regiszterbe írjuk, elõbb ellenõrizni kell, hogy a regiszter értéke szerint (amit a játék állít be) a játék mely gombcsoportra kíváncsi. Ezen kód értelmezésével tehát sok-sok órányi \textit{debuggolástól} kímélheti meg magát a fejlesztõ -- ez a többi területre is érvényes: érdemes, sõt, ajánlott a játékok kódját visszafejteni, és megnézni hogy mit hogyan csinálnak, mely memóriaterületekre írnak, hogyan kezelik a gomblenyomást, stb., hiszen végsõ soron az emulátor implementálásának ``másik fele'' a célhardverre írt játékok kódja: az egyik nem mûködik a másik nélkül. \\
Most, hogy már tisztában vagyunk a megfelelõ regiszterrel, illetve azzal, hogy a játékok hogyan veszik hasznát a gomboknak, hogyan detektálják azok lenyomását, érdemes megtervezni az emulátor gomblenyomásának kezelését. 

\subsection{Gombnyomás detektálás}

Ahhoz, hogy detektálni tudjuk egy gomb lenyomását, és egyúttal reagálni tudjunk rá, szükségünk van egy külsõ könyvtárra, amely megvalósítja ezt a fajta eseménykezelést. Az emulátor fejlesztésének kezdetén, mikor a \textit{framebuffert} megvalósító \textit{library} kiválasztására került a sor, figyelembe vettem, hogy késõbb szükség lesz majd a gombnyomások ke\-ze\-lé\-sé\-re is -- így esett a választás a 2.2.2-es szakaszban taglalt \texttt{minifb} könyvtárra. Ez a könyvtár nemcsak a renderelést könnyíti meg, hanem képes arra, amire most szükségünk van: a gombnyomások regisztrálására. \\
A \texttt{minifb} \textit{crate} \texttt{Window} struktúrája valósítja meg a renderelésnél is használt ablak megjelenítését, frissítését, és egyéb funkciókat, például a billentyû lenyomásának ke\-ze\-lé\-sét. A billentyûzettel kapcsolatos függvények, és azok magyarázatai a következõk:

\begin{itemize}
  \item \mintinline{rust}{fn get_keys(&self)}\!: az aktuálisan lenyomott billentyûk azonosítóit adja visz\-sza egy \mintinline{rust}{Option<Vec<Key>>} értékként, ezeket iterátorral tudjuk bejárni.
  \item \mintinline{rust}{fn get_keys_pressed(&self, repeat: KeyRepeat)}\!: az elõzõ függ\-vény\-hez hasonló módon a lenyomott billentyûket adja vissza egy tömbben, azonban a \mintinline{rust}{repeat} paraméterben meg lehet adni, hogy kiszûrje a folyamatosan nyomva tartott bil\-len\-tyû\-ket.
  \item \mintinline{rust}{fn is_key_down(&self, key: Key)}\!: a \mintinline{rust}{key} paraméterben megadott bil\-len\-tyûazonosítóhoz tartozó billentyû lenyomását vizsgálja, egy \mintinline{rust}{bool} értékkel tér vissza. A visszatérési érték akkor lesz igaz, ha a billentyû éppen le van nyomva.
  \item \mintinline{rust}{fn is_key_pressed(&self, key: Key, repeat: KeyRepeat)}\!: az elõzõ két függvény ötvözete: egy \mintinline{rust}{bool} értékkel tér vissza, amelynek értéke 1, ha a paraméterben megadott azonosítóhoz tartozó billentyû le van nyomva, illetve szintén paraméterben megadható a folyamatosan lenyomott billentyûk kiszûrése is.
\end{itemize}

\noindent Ezek közül a függvények közül végül a legegyszerûbb mûködésû \mintinline{rust}{is_key_down}-t vá\-lasz\-tot\-tam (annak ellenére, hogy az összes többivel megvalósítható a mûködés), amely segítségével az alábbi, \ref{table:51}-es táblázatban szereplõ megfeleltetések sze\-rint vizsgálom a lenyomott billentyûket:

\begin{table}[h!]
  \centering
  {\renewcommand{\arraystretch}{1.3}
  \begin{tabu}{ |>{\columncolor{GameBoyBlue}}l|[2pt]c|c|c|c|c|c|c|c| } 
   \hline
   \textbf{A Game Boy gombjai} &\textit{Jobbra} & \textit{Balra} & \textit{Fel} & \textit{Le} & \textit{A} & \textit{B} & \textit{Select} & \textit{Start} \\ \hline
   \textbf{Megfeleltetett gombok} &\textit{D} & \textit{A} & \textit{W} & \textit{S} & \textit{J} & \textit{K} & \textit{Space} & \textit{Right Shift} \\ \hline
   \textbf{Azonosítók} & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\ \hline
  \end{tabu}}
  \caption{\textit{A gombok kiosztása a billentyûzeten}}
  \label{table:51}
\end{table}

\noindent Így például a \textit{jobbra} gombnak megfeleltetett \textit{D} gomb lenyomását az alábbiak szerint vizsgálom:

\begin{minted}{rust}
  if window.is_key_down(Key::D) {
    self.pressed_button(0, cpu);
  } else { 
    self.released_button(0); 
  }
\end{minted}

\noindent A fenti kódrészlet a gomblenyomás kezelését megvalósító \mintinline{rust}{Joypad} struktúrában szereplõ \mintinline{rust}{scan_window_button_pressed} függvény része. Minden lehetséges billentyûre (8 darab) meg van írva a megfelelõ \texttt{pressed} és \texttt{released} állapothoz tartozó függ\-vény\-hí\-vás. Ez a \mintinline{rust}{scan_window_button_pressed} függvény minden CPU ciklus elején meghívódik a fõ ciklusban. \\
A \mintinline{rust}{released_button} egész egyszerûen veszi a felengedett billentyû azonosítóját, és a \textit{Joypad Registerben} 1-re állítja az értékét. \\
A \mintinline{rust}{pressed_button} mûködése azonban kissé bonyolultabb. Ez a függvény elõször is megvizsgálja, hogy a paraméterben kapott gomb (billentyû) állapota változott-e a leg\-u\-tób\-bi\-hoz képest, majd ez alapján beállít egy \mintinline{rust}{bool} típusú változót. Ezt követõen megállapítja az azonosító alapján, hogy a kapott gomb melyik csoportba tartozik, majd lementi az \texttt{0xFF00} aktuális állapotát egy változóba. A következõ lépés az, hogy az adott gomb\-cso\-port\-hoz tartozó, kijelölõ bit állapotát figyelembe véve megállapítja, hogy a játék kí\-ván\-csi-e az adott gomb lenyomására, és ha igen, (és az elsõ lépés szerint állapotváltozás is történt), akkor megszakítási kérelmet küld a processzornak. \\
Az utolsó gombnyomással kapcsolatos függvény az \mintinline{rust}{update_state}, amely a fejezet bevezetõjében lévõ kód kapcsán ismertetett leírásnak megfelelõen megnézi, hogy a játék melyik gombcsoportra kíváncsi, majd aszerint frissíti az \texttt{0xFF00} címen lévõ \textit{Joypad Registert}. Ezt a függvényt is a \mintinline{rust}{scan_window_button_pressed}-hez hasonlóan meg kell hívni minden CPU ciklus elején, és visszatérési értékével frissíteni kell a \textit{Joypad Registert}.